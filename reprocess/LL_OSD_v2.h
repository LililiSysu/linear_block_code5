#pragma once
/*****************************************************************//**
 * \file   LL_OSD_v2.h
 * \brief  LL OSD as a new realization
 *
 * \author 26259
 * \date   March 2024
 *********************************************************************/

#include"OSD.h"
#include"../code/RS.h"
#include"../code/BCH.h"

// only for binary primitive narrow-sence BCH codes
template<int m, int t>
class LL_OSD_v2 {
protected:

	RS<m, (1 << m) - 1 - 2 * t> rs;
	BCH<m, t> bch;
	int n;
	int k;
	int k_prime;
	int min_Hamming_distance;

	// variables during decoding
	Matrix<int> r_abs_Gs_record;			// Permutation for obtaining MRIPs
	Matrix<GF2> y;						// Hard-decisions of received vector
	Matrix<my_double> r_abs;				// Received vector in absolute value
	Matrix<my_double> r_Gs;			// Permuted received vector
	Matrix<my_double> r_abs_Gs;		// Permuted received vector in absolute value
	Matrix<GF2e<m>> Gs;					// Systematic generator matrix corresponding to MRIPs, non-binary
	Matrix<GF2> y_Gs;					// Permuted hard-decisions of received vector
	Matrix<GF2e<m>> c0_Gs;					// First permuted codeword candidate
	Matrix<GF2e<m>> cb_Gs;					// The best permuted codeowrd candidate
	my_double w_min;							// Minimum sort Hamming weight that is recorded through re-encoding
	OSD_TEP TEP_generator;				// TEP 'TEP_generator.now' will be generated sequentially
	Matrix<GF2e<m>> ce_Gs;					// Permuted codeowrd candidate generated by TEP 'TEP_generator.now'
	my_double w_ce_Gs;						// Sort Hamming weight of 'ce_Gs'
	int error_num;								// Number of different bits between 'y_Gs' and 'ce_Gs' ( 'c0_Gs' when in phase-0 )

	my_double G_threshold;					// threshold for ML criterion
	my_double G_OSD_threshold;				// soft Hamming weight lower bound for OSD phase-i re-processing
	Matrix<my_double> G_threshold_component;	// store r_abs_bar values adding in that constitute G_threshold

	Matrix<int> permutation_first;		// Permutation that ensures decreasing reliability
	Matrix<int> info_set_rs;			// RS MRB, first 'k' entries of 'permutation_first'

	bool current_codeword_binary;		// if true, re-encode into a binary codeword
	Matrix<int> row_add_index;			// the rows to add for re-encoding
	Matrix<int> sys_order_inv;			// inverse permutation of 'sys_order' below
	Matrix<int> sys_order;				// map the re-encoding TEP into rows in Gs

public:
	int order;
	Matrix<GF2> c_hat;					// Optimal codeword for output
	int type;

	// simulation statistics
	int TEP_num;						// number of TEP used for re-encoding
	bool is_early_termination;			// if ture, the decoding is terminated by stopping condition
	bool has_codeword_binary;			// if ture, already have a binary codeword, this is actually used in decoding
	int binary_codeword_num;			// number of binary BCH codeword generated

	// interface
	my_double sigma;					// denote the received signal noise, keep for order-skipping condition
	int ET_type;						// 0 -> no stopping criterion; 1 -> general ML stopping criterion; 
										// 2 -> OSD specific ML stopping criterion; 3 -> OS stopping cirterion
										// 4 -> Hamming distance criterion, threshold = d / 2 = t

	LL_OSD_v2(int _order) : TEP_generator(rs.get_k()) {

		n = (1 << m) - 1;
		k = bch.get_k();
		k_prime = n - 2 * t;

		min_Hamming_distance = bch.get_d();
		order = _order;
		r_abs.resize(1, n);
		y.resize(1, n);
		c0_Gs.resize(1, n);
		ce_Gs.resize(1, n);
		c_hat.resize(1, n);
		row_add_index.resize(1, k_prime);

		// initialize to arbitary values
		w_min = 0;
		w_ce_Gs = 0;
		error_num = 0;
		G_threshold = 0;
		G_OSD_threshold = 0;

		current_codeword_binary = false;
		has_codeword_binary = false;

		cout << "LL_OSD_v2(" << _order << ")" << endl;
		type = 10;

		TEP_num = 0;
		is_early_termination = false;
		binary_codeword_num = 0;

		sigma = 0;				// reset arbitary, need to change with the channel SNR
		ET_type = 3;			// the most efficient and non-significant performance loss ET
	}
	
	void call_GE_only(const Matrix<my_double>& r) {
		for (int i = 0; i < n; ++i) {
			r_abs[i] = my::abs(r[i]);
			y[i] = r[i] > 0 ? 0 : 1;
		}
		permutation_first = Matrix<int>(1, n, 'N');								// Vector_ext::natual<n>(permutation_first);

		r_abs_Gs = r_abs;
		r_abs_Gs.quick_sort_recur_gt_with_ind(0, n - 1, permutation_first);	// r_abs.sort_gt_with_record(permutation_first, r_abs_bar);

		info_set_rs = permutation_first.get_part(0, 0, 0, k_prime - 1);
		rs.generate_systematic_generator_any_pos_best(info_set_rs);

		Gs = rs.generator_M_systematic_any_pos;
		Gs.permute_col(permutation_first);
		// G.permute_column(permutation_first, Gs);

		//cout << "Gs" << Gs;

		r_Gs = r;
		r_Gs.permute(permutation_first);
		//cout << "r_Gs" << r_Gs;

		y_Gs = y;
		y_Gs.permute(permutation_first);										// y.permute(permutation_first, y_bar);
		//cout << "y_Gs" << y_Gs;
	}

	// the decoding result is 'c_hat', which can be fetched from the class
	void solve(const Matrix<my_double>& r) {
		for (int i = 0; i < n; ++i) {
			r_abs[i] = my::abs(r[i]);
			y[i] = r[i] > 0 ? 0 : 1;
		}
		permutation_first = Matrix<int>(1, n, 'N');								// Vector_ext::natual<n>(permutation_first);


		r_abs_Gs = r_abs;
		r_abs_Gs.quick_sort_recur_gt_with_ind(0, n - 1, permutation_first);	// r_abs.sort_gt_with_record(permutation_first, r_abs_bar);

		info_set_rs = permutation_first.get_part(0, 0, 0, k_prime - 1);

		//// testing non-all sort, the MRIP part and LRP part is unsorted -----------
		
		//Matrix<int> red_set_rs = permutation_first.get_part(0, k_prime, 0, n - 1);
		//info_set_rs.permute_rand();
		//red_set_rs.permute_rand();
		//permutation_first = info_set_rs.combine_right(red_set_rs);
		//r_abs_Gs = r_abs;
		//r_abs_Gs.permute(permutation_first);

		//// test ended here --------------

		// record re-encoding rows, pay attention to write comments
		sys_order_inv = info_set_rs.sort_with_ind('<');
		// find the inverse of 'sys_order_inv', that is re-encoding rows order
		sys_order = Matrix<int>(1, k_prime, 'N');
		sys_order.permute_back(sys_order_inv);
		//cout << "sys_order = " << sys_order;

		rs.generate_systematic_generator_any_pos_best(info_set_rs);

		Gs = rs.generator_M_systematic_any_pos;
		Gs.permute_col(permutation_first);
		// G.permute_column(permutation_first, Gs);

		//cout << "Gs" << Gs;

		r_Gs = r;
		r_Gs.permute(permutation_first);
		//cout << "r_Gs" << r_Gs;

		y_Gs = y;
		y_Gs.permute(permutation_first);										// y.permute(permutation_first, y_bar);
		//cout << "y_Gs" << y_Gs;

		//cout << "my_double_auxiliary_storage::operation_number (1) = " << my_double_auxiliary_storage::operation_number << endl;
		//cout << "GF2e_auxiliary_storage::operation_number (1) = " << GF2e_auxiliary_storage::operation_number << endl;

		//y_Gs.get_part<k>(0, k - 1, yB_Gs);
		//cout << "yB_Gs" << yB_Gs;

		TEP_num = 0;
		is_early_termination = false;
		binary_codeword_num = 0;

		//c0_Gs = yB_Gs * Gs;
		first_re_encoding();
		//cout << "c0_Gs" << c0_Gs;

		if (current_codeword_binary == true) {

			w_min = soft_Hamming_weight(c0_Gs);
		}
		else {
			w_min = 3e10;		// a super large number
		}
		//cout << "w_min = " << w_min << endl;

		cb_Gs = c0_Gs;
		//cout << "cb_Gs" << cb_Gs;

		//cout << "my_double_auxiliary_storage::operation_number (2) = " << my_double_auxiliary_storage::operation_number << endl;
		//cout << "GF2e_auxiliary_storage::operation_number (2) = " << GF2e_auxiliary_storage::operation_number << endl;


		if (phase_0_termination() == true) {
			return;
		}

		//cout << "my_double_auxiliary_storage::operation_number (3) = " << my_double_auxiliary_storage::operation_number << endl;
		//cout << "GF2e_auxiliary_storage::operation_number (3) = " << GF2e_auxiliary_storage::operation_number << endl;

		//cout << "c0_Gs" << c0_Gs;
		//cout << "d_min = " << d_min << endl;

		//cout << "G_threshold_component" << G_threshold_component;
		//cout << "G_threshold = " << G_threshold << endl;

		for (int i = 1; i <= order; ++i) {
			TEP_generator.set_weight(i);

			if (new_order_termination(i) == true) {
				return;
			}

			while (TEP_generator.now[0] >= 0) {

				//cout << "TEP_generator.now" << TEP_generator.now;

				re_encoding(TEP_generator.now);

				//cout << "ce_Gs" << ce_Gs;

				if (current_codeword_binary == true) {

					w_ce_Gs = soft_Hamming_weight(ce_Gs);
					//cout << "w_ce_Gs = " << w_ce_Gs << endl;

					if (w_ce_Gs < w_min) {
						w_min = w_ce_Gs;
						cb_Gs = ce_Gs;

						if (optimal_termination(i) == true) {
							return;
						}						
					}
				}
				TEP_generator.next();
			}
		}

		//cout << "my_double_auxiliary_storage::operation_number (5) = " << my_double_auxiliary_storage::operation_number << endl;
		//cout << "GF2e_auxiliary_storage::operation_number (5) = " << GF2e_auxiliary_storage::operation_number << endl;

		//cout << "cb_Gs" << cb_Gs;
		//c_hat = cb_Gs;
		convert_to_c_hat();
		c_hat.permute_back(permutation_first);
		return;
	}

	void first_re_encoding() {
		// re-encode 'yB_Gs' into 'c0_Gs', i.e., c0_Gs = yB_Gs * Gs;

		// reset to all-0 vector
		c0_Gs.reset(0);
		row_add_index.clear();

		for (int j = 0; j < k_prime; ++j) {

			if (y_Gs[j] == 1) {		// consider to write it as 'yB_Gs[j] + 1 == 0' for counting one GF2 operation

				// copy systematic part
				c0_Gs[j] = y_Gs[j];

				row_add_index.push_back(j);
			}
		}

		// re-encode parity-check part
		current_codeword_binary = true;
		for (int p = k_prime; p < n; ++p) {
			int row_add_num = row_add_index.size();
			for (int i = 0; i < row_add_num; ++i) {
				c0_Gs[p] += Gs(sys_order(row_add_index(i)), p);		// add accumulately, this cause my second problem, mark down here
			}

			// judeg if c0_Gs is binary
			if (c0_Gs[p] == 0 || c0_Gs[p] == 1);
			else {
				current_codeword_binary = false;					// do not break, re-encode the first codeword is necessary
			}
		}
		has_codeword_binary = current_codeword_binary;

		if (has_codeword_binary == true) {
			binary_codeword_num++;
		}
		TEP_num++;
	}

	void re_encoding(const Matrix<int>& TEP_now) {
		// re-encode to ce_Gs

		// initialize ans
		ce_Gs = c0_Gs;

		row_add_index.clear();
		for (int j = 0; j < TEP_now.size(); ++j) {
			// flip systematic part
			//ce_Gs[TEP_now[j]] += GF2e<m>(1);		// flip the binary bit, moving it after binary judgement, saving computations
			row_add_index.push_back(TEP_now[j]);			
		}

		// re-encode parity-check part
		current_codeword_binary = true;
		for (int p = k_prime; p < n; ++p) {
			int row_add_num = row_add_index.size();
			for (int i = 0; i < row_add_num; ++i) {
				ce_Gs[p] += Gs(sys_order(row_add_index(i)), p);		// add accumulately, this cause my second problem, mark down here
			}

			// judeg if c0_Gs is binary
			if (ce_Gs[p] == 0 || ce_Gs[p] == 1);
			else {
				current_codeword_binary = false;
				break;
			}
		}

		if (current_codeword_binary == true) {
			has_codeword_binary = true;
			binary_codeword_num++;

			for (int j = 0; j < TEP_now.size(); ++j) {
				// flip systematic part
				ce_Gs[TEP_now[j]] += GF2e<m>(1);		// flip the binary bit, maybe should be counted as binary operations, doesn't matter
			}
		}

		TEP_num++;
	}

	my_double soft_Hamming_weight(const Matrix<GF2e<m>>& c_Gs) {
		my_double ans = 0;
		error_num = 0;
		for (int i = 0; i < n; ++i) {
			if (c_Gs[i] != (GF2e<m>)y_Gs[i]) {
				ans += r_abs_Gs[i];
				error_num++;
			}
		}
		return ans;
	}

	bool check_ML_codeword_general() {
		// Will always check cb_Gs		
		// 'G_threshold(c_Gs,d)' is only needed to compute

		// Only need 'D0_add_size' reliabilities adding up to form the 'G_threshold'
		int D0_add_size = min_Hamming_distance - error_num;

		// This re-arrange the codeword candidate in decreasing reliability. If not, will not guarantee an ML codeword

		G_threshold = 0;

		for (int i = n - 1; i >= 0 && D0_add_size > 0; --i) {

			if (cb_Gs[i] == (GF2e<m>)y_Gs[i]) {		// 'D0' set, traverse starting from the least reliable position
				G_threshold += r_abs_Gs[i];
				D0_add_size--;

				//if (w_min < G_threshold) return true;		// in align with Guo's program
			}
		}
		return (w_min < G_threshold);
		//return false;		// ML criterion for general codeword
	}

	bool check_ML_codeword_OSD_specific(int TEP_weight) {
		// Will always check cb_Gs		
		// 'G_threshold(c_Gs,d)' is only needed to compute

		G_threshold = G_OSD_threshold;
		/*for (int i = 0; i < TEP_weight; ++i) {
			G_threshold += r_abs_Gs[k - 1 - i];
		}*/

		// Only need 'D0_add_size' reliabilities adding up to 'G_threshold' further form the entire 'G_threshold'
		int D0_add_size = min_Hamming_distance - error_num - TEP_weight;

		// This re-arrange the codeword candidate in decreasing reliability. If not, will not guarantee an ML codeword

		G_threshold_component.clear();

		for (int i = n - 1; i >= 0 && D0_add_size > 0; --i) {

			if (cb_Gs[i] == (GF2e<m>)y_Gs[i]) {		// 'D0' set, traverse starting from the least reliable position
				G_threshold += r_abs_Gs[i];
				D0_add_size--;

				// if (w_min < G_threshold) return true;	// in align with Guo
				G_threshold_component.push_back(r_abs_Gs[i]);
			}
		}
		return (w_min < G_threshold);
		//return false;		// ML criterion for general codeword
	}

	bool check_ML_codeword_OSD_new_phase(int phase_num) {

		//cout << "r_abs_Gs" << r_abs_Gs;
		//cout << "r_abs_Gs[k - phase_num] = " << r_abs_Gs[k - phase_num] << endl;

		// update 'G_threshold' for a new judgement
		if (!G_threshold_component.empty()) {

			G_threshold += r_abs_Gs[k_prime - phase_num] - G_threshold_component.back();
			G_threshold_component.pop_back();
		}
		else {
			G_threshold += r_abs_Gs[k_prime - phase_num];
		}

		// judge the current best codeword if it is ML
		if (w_min < G_threshold) {
			return true;
		}
		else {
			// update 'G_OSD_threshold' for the following codeword candidates
			G_OSD_threshold += r_abs_Gs[k_prime - phase_num];
			return false;
		}
	}

	void G_threshold_OS_OSD_ini() {
		G_threshold = 0;

		my_double scale_by_sigma = 2 / (sigma * sigma);
		for (int i = k_prime; i < n; ++i) {
			G_threshold += r_abs_Gs(i) / (1 + exp(scale_by_sigma * r_abs_Gs(i)));
		}
	}

	void G_threshold_OS_OSD_increase(int phase_num) {
		G_threshold += r_abs_Gs(k_prime - phase_num);
	}

	bool check_codeword_OS_OSD() {
		// Will always check cb_Gs		

		return w_min < G_threshold;
	}

	bool check_codeword_Hamming_distance(int phase_num) {
		int Hamming_dist = phase_num;
		for (int i = k_prime; i < n; ++i) {
			if ((cb_Gs[i] != (GF2e<m>)y_Gs[i])) {
				Hamming_dist++;		// compute Hamming distance of current codeword and hard decision vector
			}
		}
		return Hamming_dist <= t;	// if Hamming distance is less than d / 2, terminate decoding
	}

	void convert_to_c_hat() {
		//c_hat = (binary) cb_Gs;
		for (int i = 0; i < n; ++i) {
			c_hat[i] = (GF2)cb_Gs[i];
		}
	}

	void early_termination() {
		convert_to_c_hat();
		c_hat.permute_back(permutation_first);
		is_early_termination = true;
		return;
	}

	bool phase_0_termination() {
		if (ET_type == 1) {
			if (current_codeword_binary == true && check_ML_codeword_general() == true) {		// in order-0, this is the same as the OSD specific type			
				//c_hat = cb_Gs;
				early_termination();
				return true;
			}
		}
		else if (ET_type == 2) {
			G_OSD_threshold = 0;

			if (current_codeword_binary == true && check_ML_codeword_OSD_specific(0) == true) {		// in order-0, this is the same as the OSD specific type			
				//c_hat = cb_Gs;
				early_termination();
				return true;
			}
		}
		else if (ET_type == 3) {

			G_threshold_OS_OSD_ini();
			if (current_codeword_binary == true && check_codeword_OS_OSD() == true) {		// use order-skipping ET in order-0
				early_termination();
				return true;
			}
		}
		else if (ET_type == 4) {
			if (current_codeword_binary == true && check_codeword_Hamming_distance(0) == true) {
				early_termination();
				return true;
			}
		}
		return false;
	}

	bool new_order_termination(int i) {

		if (ET_type == 2) {
			if (has_codeword_binary == true && check_ML_codeword_OSD_new_phase(i) == true) {
				early_termination();
				return true;
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
			}
		}
		else if (ET_type == 3) {
			G_threshold_OS_OSD_increase(i);
			if (has_codeword_binary == true && check_codeword_OS_OSD() == true) {
				early_termination();
				return true;
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
			}
		}
		return false;
	}

	bool optimal_termination(int i) {
		if (ET_type == 1) {
			if (check_ML_codeword_general() == true) {
				early_termination();
				return true;
			}
		}
		else if (ET_type == 2) {
			if (check_ML_codeword_OSD_specific(i) == true) {		// it actually is an ML criterion even for LLOSD
				//c_hat = cb_Gs;
				early_termination();
				return true;
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
			}
		}
		else if (ET_type == 3) {
			if (check_codeword_OS_OSD() == true) {
				early_termination();
				return true;
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
			}
		}
		else if (ET_type == 4) {
			if (check_codeword_Hamming_distance(i) == true) {
				early_termination();
				return true;
			}
		}
		return false;
	}
};

