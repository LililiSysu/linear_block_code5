/*****************************************************************//**
 * \file   Adaptive_GE_OSD.h
 * \brief  Use probability condition to avoid GE adaptively, Yue's method
 * 
 * \author 26259
 * \date   March 2024
 *********************************************************************/
#pragma once

#include"OSD.h"

class Adaptive_GE_OSD {
protected:
	int n;
	int k;
	int min_Hamming_distance;

	// variables during decoding
	Matrix<int> r_abs_Gs_record;			// Permutation for obtaining MRIPs
	Matrix<GF2> y;						// Hard-decisions of received vector
	Matrix<my_double> r_abs;				// Received vector in absolute value
	Matrix<my_double> r_Gs;			// Permuted received vector
	Matrix<my_double> r_abs_Gs;		// Permuted received vector in absolute value
	Matrix<GF2> Gs;					// Systematic generator matrix corresponding to MRIPs
	Matrix<GF2> Hs;					// Systematic generator matrix corresponding to MRIPs
	Matrix<GF2> y_Gs;					// Permuted hard-decisions of received vector
	Matrix<GF2> c0_Gs;					// First permuted codeword candidate
	Matrix<GF2> cb_Gs;					// The best permuted codeowrd candidate
	my_double w_min;							// Minimum sort Hamming weight that is recorded through re-encoding
	OSD_TEP TEP_generator;				// TEP 'TEP_generator.now' will be generated sequentially
	Matrix<GF2> ce_Gs;					// Permuted codeowrd candidate generated by TEP 'TEP_generator.now'
	my_double w_ce_Gs;						// Sort Hamming weight of 'ce_Gs'
	int error_num;								// Number of different bits between 'y_Gs' and 'ce_Gs' ( 'c0_Gs' when in phase-0 )

	my_double G_threshold;					// threshold for ML criterion
	my_double G_OSD_threshold;				// soft Hamming weight lower bound for OSD phase-i re-processing
	Matrix<my_double> G_threshold_component;	// store r_abs_bar values adding in that constitute G_threshold

	Matrix<int> permutation_first;		// Permutation that ensures decreasing reliability
	Matrix<int> permutation_second;		// Permutation that ensures the Gs systematic on left, disrupts decreasing reliability
	Matrix<int> permutation_all;			// Permutation that combines 'permutation_first' and 'permutation_second'
	Matrix<my_double> r_abs_bar;			// 'r_abs' sorted in REAL decreasing reliability, 'r_abs_Gs' without 'permutation_second'
	Matrix<GF2> y_bar;					// 'y_Gs' without 'permutation_second'
	Matrix<GF2> cb_bar;					// 'cb_Gs' without 'permutation_second'

	// Adaptive_GE_variables
	Matrix<my_double> P_i;				// the error probability of the i-th symbol
	my_double Prod_k_P_i;				// accumulate product of (1 -P_i[i]) for i = 0,1,... n-k
	my_double Prod_n_P_i;				// accumulate product of (1 -P_i[i]) for i = 0,1,... n-1
	Matrix<GF2> Gs_un_permuted;			// the Generator matrix in systematic form without permutation 
										// (assume the first 'k' positions can form an information set)

	Matrix<GF2> Hs_un_permuted;			// the Parity-check matrix in systematic form without permutation 
										// (assume the last 'n' - 'k' positions can form an information set for dual code)
	my_double w_min_first_k;			// the first 'k' position accumulation of minimum sort Hamming weight, i.e., 'w_min'
	bool cb_Gs_need_permute_back;		// if true, a permutation is needed to generate 'c_hat' from c_b
	my_double scale_by_sigma;			// equals to 2 / (sigma * sigma), set before each decoding

	// middle result of Adaptive GE
	my_double p_MRB_ave;				// the average error probability of the MRB positions
	my_double p_first_k_ave;			// the average error probability of the first k positions
	my_double p_last_n_minus_k_ave;		// the average error probability of the last (n-k) positions

	my_double P_list;					// the probability of at most 'order' error occur in the MRB
	my_double P_list_prime;				// the probability of at most 'order_prime' errors occur in the first 'k' positions

	// for discarding rule, a bit complex
	my_double Pe;						// probability that TEP correctly erases the errors in information set
	my_double Ep_alpha;					// the arithmethic mean of reliability in the last (n-k) positions
	int beta;							// the expected number of errors in the last (n-k) positions for the re-encoding result of a TEP
	int N_m_prime;						// sum of n_choose_k(k,i) for i = 0,1, ... ,order_prime

public:
	Matrix<GF2> G;
	Matrix<GF2> H;
	int order;
	Matrix<GF2> c_hat;					// Optimal codeword for output
	int type;
	bool by_generator;

	// simulation statistics
	int TEP_num;						// number of TEP used for re-encoding
	bool is_early_termination;			// if ture, the decoding is terminated by stopping condition

	// interface
	my_double sigma;					// denote the received signal noise, keep for order-skipping condition
	int ET_type;						// 0 -> no stopping criterion; 1 -> general ML stopping criterion; 
	// 2 -> OSD specific ML stopping criterion; 3 -> OS stopping cirterion

	// Adaptive GEm parameters
	my_double lambda;					// for condition 1, whether to execute non-GE OSD
	my_double tau;						// for condition 2, whether to stop re-encoding in non-GE OSD
	my_double tau_p;					// for discarding rule in non-GE re-encoding, derived by PB-OSD
	my_double order_prime;				// re-processing order for non-GE OSD
	bool is_GE_skip;

	Adaptive_GE_OSD(const Matrix<GF2>& _G, const Matrix<GF2>& _H, int _d, int _order \
	) : TEP_generator(_G.row() <= _H.row() ? _G.row() : _H.col() - _H.row()) {

		by_generator = _G.row() <= _H.row();
		n = by_generator ? _G.col() : _H.col();

		type = 41;
		cout << "Adaptive_GE_OSD(" << _order << ")" << endl;

		if (by_generator == true) {
			G = _G;
			k = G.row();
		}
		else {
			H = _H;
			k = n - H.row();
			Gs = Matrix<GF2>(k, n, 'i');
		}

		min_Hamming_distance = _d;
		order = _order;
		r_abs.resize(1, n);
		y.resize(1, n);
		c0_Gs.resize(1, n);
		ce_Gs.resize(1, n);

		// initialize to arbitary values
		w_min = 0;
		w_ce_Gs = 0;
		error_num = 0;
		G_threshold = 0;
		G_OSD_threshold = 0;

		TEP_num = 0;
		is_early_termination = false;

		sigma = 0;				// reset arbitary, need to change with the channel SNR
		ET_type = 3;			// the most efficient and non-significant performance loss ET

		scale_by_sigma = INFINITY;		// reset arbitary.
		P_i.resize(1, n); 
		p_MRB_ave = 0;
		p_first_k_ave = 0;
		p_last_n_minus_k_ave = 0;
		P_list = 0;
		P_list_prime = 0;
		
		order_prime = my::max(order - 1, 1);	// the non-GE OSD is always set to be 'order'-1 here, however, it could be set to 'order' or fixed for 1
		lambda = 0.05;				// empirical parameter for condition 1, keep it consistant with Yue's paper
		tau = 0.95;					// emperical parameter for condition 2, the required success probability to terminate re-encoding
		tau_p = 0;					// set arbitary, this is dependent on channel condition
		is_GE_skip = false;

		N_m_prime = 0;				// if order order_prime, this should be changed
		for (int i = 0; i <= order_prime; ++i) {
			N_m_prime += my::n_choose_k(k, i);
		}


		Matrix<int> nat(1, n, 'N');
		if (by_generator == true) {
			Gs_un_permuted = G;
			// G.permute_column(permutation_first, Gs);

			Gs_un_permuted.GJE_4_GF2_left(nat);
			//cout << "Gs" << Gs;
		}
		else {
			Hs_un_permuted = H;

			Hs_un_permuted.GJE_4_GF2_right(nat);

			// set Gs = [I_k | P^T]
			Gs_un_permuted = Matrix<GF2>(k, n, 'i');
			for (int q = 0; q < k; ++q) {
				for (int j = k; j < n; ++j) {
					Gs_un_permuted(q, j) = Hs_un_permuted(j - k, q);
				}
			}
			//cout << "Gs" << Gs;
		}
	}

	bool condition_1_on_the_fly(const Matrix<my_double>& r) {
		for (int i = 0; i < n; ++i) {
			r_abs[i] = my::abs(r[i]);
			y[i] = r[i] > 0 ? 0 : 1;
		}

		permutation_first = Matrix<int>(1, n, 'N');								// Vector_ext::natual<n>(permutation_first);
		r_abs_bar = r_abs;
		r_abs_bar.quick_sort_recur_gt_with_ind(0, n - 1, permutation_first);	// r_abs.sort_gt_with_record(permutation_first, r_abs_bar);

		//cout << "r_abs_bar" << r_abs_bar;

		for (int i = 0; i < n; ++i) {
			P_i[i] = 1 / (1 + exp(scale_by_sigma * r_abs_bar[i]));	
					// it is actually 'P_i_tilde' now, the error probability of the i-th sorted symbol
		}
		//cout << "P_i" << P_i;

		// ----------------------------- //
		// compute P_list
		// ----------------------------- //
		p_MRB_ave = 0;						// the average error probability of the MRB positions
		for (int i = 0; i < k; ++i) {
			p_MRB_ave += P_i[i];
		}
		p_MRB_ave /= k;
		//cout << "p_MRB_ave = " << p_MRB_ave << endl;
		my_double one_minus_p_MRB_ave = 1 - p_MRB_ave;

		P_list = 0;				// the probability of at most 'order' errors occur in the MRB
		for (int i = 0; i <= order; ++i) {
			P_list += my::n_choose_k(k, i) * pow(p_MRB_ave, i) * pow(one_minus_p_MRB_ave, k - i);
		}

		P_i.permute_back(permutation_first);			// now it become real 'P_i', the error probability of the i-th symbol

		// ----------------------------- //
		// compute P_list_prime
		// ----------------------------- //
		p_first_k_ave = 0;					// the average error probability of the first 'k' positions
		for (int i = 0; i < k; ++i) {
			p_first_k_ave += P_i[i];
		}
		p_first_k_ave /= k;
		//cout << "p_first_k_ave = " << p_first_k_ave << endl;
		my_double one_minus_p_first_k_ave = 1 - p_first_k_ave;

		P_list_prime = 0;			// the probability of at most 'order_prime' errors occur in the first 'k' positions
		for (int i = 0; i <= order_prime; ++i) {
			P_list_prime += my::n_choose_k(k, i) * pow(p_first_k_ave, i) * pow(one_minus_p_first_k_ave, k - i);
		}		

		// judge condition 1
		return P_list_prime >= (1 - lambda) * P_list;
	}

	my_double non_GE_soft_Hamming_weight_first_k(const Matrix<int>& TEP_now) {
		my_double _w_fist_k = 0;
		int TEP_size = TEP_generator.now.size();
		for (int i = 0; i < TEP_size; ++i) {
			_w_fist_k += r_abs[TEP_now[i]];
		}
		error_num = TEP_size;
		return _w_fist_k;
	}

	my_double non_GE_soft_Hamming_weight(const Matrix<GF2>& c_Gs, my_double _w_first_k) {

		my_double _w_can = _w_first_k;
		for (int i = k; i < n; ++i) {
			if (c_Gs[i] != y[i]) {
				_w_can += r_abs[i];
				error_num++;
			}
		}
		return _w_can;
	}

	void accumulate_product_one_minus_P_i() {

		// accumulate product if (1-P(e(i))
		Prod_k_P_i = 1;
		for (int i = 0; i < k; ++i) {
			Prod_k_P_i *= (1 - P_i(i));
		}

		Prod_n_P_i = Prod_k_P_i;
		for (int i = k; i < n; ++i) {
			Prod_n_P_i *= (1 - P_i(i));
		}

	}

	void common_computation() {

		// compute the average probability of bits in the last (n-k) positions
		p_last_n_minus_k_ave = 0;
		for (int i = k; i < n; ++i) {
			p_last_n_minus_k_ave += P_i(i);
		}
		p_last_n_minus_k_ave /= (n - k);

		// compute the arithmethic mean of reliability in the last (n-k) positions
		Ep_alpha = 0;
		for (int i = k; i < n; ++i) {
			Ep_alpha += r_abs[i];
		}
		Ep_alpha /= (n - k);

		// compute threshold for discarding rule in non-GE re-encoding, derived by PB-OSD		

		//my_double p_all_ave = 2*(p_first_k_ave * k + p_last_n_minus_k_ave * (n - k)) / n;		// use it to replace p_prime = Q(sqrt(2/N0)) for convinence in c++
		//cout << "p_all_ave = " << p_all_ave << endl;		
		my_double p_prime = my::qfunc((double) sqrt((1 / sigma / sigma)));		// same as the artical of Yue.
		//cout << "p_prime = " << p_prime << endl;
		tau_p = 0.002 * sqrt(p_prime / N_m_prime);								// set for every decoding, this is too tiny, no discarding observed


		//cout << "P_list = " << P_list << endl;
		//cout << "P_list_prime = " << P_list_prime << endl;
		//cout << "1- P_list_prime = " << 1 - P_list_prime << endl;
		//tau_p = 0.002 * sqrt((1 - P_list_prime) / N_m_prime);					// set for every decoding, a previous aritcal says so, but i think it is worse

		//cout << "tau_p = " << tau_p << endl;									// problem: tau_p is too tiny, that discarding rule doesnot work
	}

	my_double compute_Pe_pro(my_double _w_first_k) {

		// compute probability that TEP correctly erases the errors in information set
		Pe = exp(-scale_by_sigma * _w_first_k) * Prod_k_P_i;
		my_double one_minus_Pe = 1 - Pe;

		// compute beta, the expected extra number of errors in the last (n-k) positions for the re-encoding result of a TEP

		int extra_error = (int)floor((double)((w_min - _w_first_k) / Ep_alpha));
		//cout << "extra_error = " << extra_error << endl;

		beta = my::min(my::max(0, extra_error), n - k);

		//cout << "beta = " << beta << endl;
		if (beta == n - k) {
			return 1;
		}

		my_double ans = 0;
		my_double one_minus_p_last_n_minus_k_ave = 1 - p_last_n_minus_k_ave;
		for (int j = 0; j <= beta; ++j) {
			ans += my::n_choose_k(n - k, j) * (Pe * pow(p_last_n_minus_k_ave, j) * pow(one_minus_p_last_n_minus_k_ave, n - k - j) + one_minus_Pe * pow(2, k - n));
		}
		//cout << "compute_Pe_pro = " << ans << endl;
		return ans;
	}

	/**
	 * .This is from [Yue. Ordered-Statistics decoding with Adaptive Gaussian, Eq.(8)], for more details check out there
	 * 
	 * \return Pr(ce|de),	the probability that a generated codeword estimate ce is the correct deocding result, 
	 *						conditioning on the difference pattern de = ce + y
	 */
	my_double compute_Pr_ce_de() {
		// NOTE: it requires the computation of Pe, which si computed in 'compute_Pe_pro'

		// for this class, let codeword 'cb_Gs' represent 'ce' and the error probability for position-i is 'P_i'

		// also the soft weight Hamming of 'cb_Gs' is computed as w_min, the first 'k' part of it is computed as 'w_min_B'

		my_double numerator = (1 - Pe) * pow(2, k - n);
		my_double denominator = exp(-scale_by_sigma * w_min) * Prod_n_P_i;

		return 1 / (1 + numerator / denominator);
	}

	bool non_GE_OSD(const Matrix<my_double>& r) {

		// traverse precomputed SGM

		Gs = Gs_un_permuted;
		y_Gs = y;						// for re-using functions 'first_re_encoding' and 're_encoding'

		accumulate_product_one_minus_P_i();				// necessary for once per received symbols, for 'compute_Pr_ce_de'

		common_computation();

		w_min_first_k = 0;
		error_num = 0;					// equivalent to calling 'w_min_first_k = non_GE_soft_Hamming_weight_first_k(Matrix<int>(1,0))'; 
		
		// for simplicity, we can remove the TEP discarding rule which is presented in PB-OSD by Yue, but we have implemented it
		
		// apply the discarding rule
		if (compute_Pe_pro(w_min_first_k) > tau_p) {

			//c0_Gs = yB_Gs * Gs;
			first_re_encoding();		

			//cout << "c0_Gs" << c0_Gs;
			//w_min = soft_Hamming_weight(c0_Gs);
			//cout << "w_min = " << w_min << endl;

			//cout << "my_double_auxiliary_storage::operation_number (2) = " << my_double_auxiliary_storage::operation_number << endl;

			w_min = non_GE_soft_Hamming_weight(c0_Gs, w_min_first_k);
			cb_Gs = c0_Gs;									// prepare for 'compute_Pr_ce_de()'

			if (compute_Pr_ce_de() >= tau) {				// also known as condition 2

				c_hat = cb_Gs;
				is_early_termination = true;

				return true;
			}
		}
		else {
			// discarding
			//cout << "discarding" << endl;		// it seems the discarding condition never satisfies
		}



		my_double w_can, w_can_first_k;
		for (int p = 1; p <= order_prime; ++p) {
			TEP_generator.set_weight(p);

			while (TEP_generator.now[0] >= 0) {

				//cout << "TEP_generator.now" << TEP_generator.now;

				// missing: discarding rules of PB-OSD by Yue, Eq(8)

				w_can_first_k = non_GE_soft_Hamming_weight_first_k(TEP_generator.now);

				// apply the discarding rule
				if (compute_Pe_pro(w_can_first_k) > tau_p) {

					re_encoding(TEP_generator.now);

					//cout << "ce_Gs" << ce_Gs;
					//w_ce_Gs = soft_Hamming_weight(ce_Gs);
					//cout << "w_ce_Gs = " << w_ce_Gs << endl;

					//if (w_ce_Gs < w_min) {
					//	w_min = w_ce_Gs;
					//	cb_Gs = ce_Gs;

					//	if (optimal_termination(i) == true) {
					//		return;
					//	}
					//}

					w_can = non_GE_soft_Hamming_weight(ce_Gs, w_can_first_k);

					if (w_can < w_min) {

						w_min = w_can;
						w_min_first_k = w_can_first_k;
						cb_Gs = ce_Gs;									// prepare for 'compute_Pr_ce_de()'

						if (compute_Pr_ce_de() >= tau) {

							c_hat = cb_Gs;
							is_early_termination = true;

							return true;
						}

					}
				}
				else {
					// discarding
					//cout << "discarding" << endl;						// it seems the discarding condition never satisfies
				}

				TEP_generator.next();
			}
		}

		return false;
	}

	void call_GE_only(const Matrix<my_double>& r) {

		//for (int i = 0; i < n; ++i) {
		//	r_abs[i] = my::abs(r[i]);
		//	y[i] = r[i] > 0 ? 0 : 1;
		//}
		//permutation_first = Matrix<int>(1, n, 'N');								// Vector_ext::natual<n>(permutation_first);
		//r_abs_bar = r_abs;
		//r_abs_bar.quick_sort_recur_gt_with_ind(0, n - 1, permutation_first);	// r_abs.sort_gt_with_record(permutation_first, r_abs_bar);
		//y_bar = y;
		//y_bar.permute(permutation_first);										// y.permute(permutation_first, y_bar);
		//Gs = G;
		//Gs.permute_col(permutation_first);
		//// G.permute_column(permutation_first, Gs);
		//permutation_second = Matrix<int>(1, n, 'N'); // Vector_ext::natual<n>(permutation_second);
		//Gs.GJE_4_GF2_left(permutation_second);
		////cout << "Gs" << Gs;

		for (int i = 0; i < n; ++i) {
			r_abs[i] = my::abs(r[i]);
			y[i] = r[i] > 0 ? 0 : 1;
		}
		permutation_first = Matrix<int>(1, n, 'N');								// Vector_ext::natual<n>(permutation_first);
		r_abs_bar = r_abs;
		r_abs_bar.quick_sort_recur_gt_with_ind(0, n - 1, permutation_first);	// r_abs.sort_gt_with_record(permutation_first, r_abs_bar);
		y_bar = y;
		y_bar.permute(permutation_first);										// y.permute(permutation_first, y_bar);

		if (by_generator == true) {
			Gs = G;
			Gs.permute_col(permutation_first);
			// G.permute_column(permutation_first, Gs);

			permutation_second = Matrix<int>(1, n, 'N'); // Vector_ext::natual<n>(permutation_second);
			Gs.GJE_4_GF2_left(permutation_second);
			//cout << "Gs" << Gs;
		}
		else {
			Hs = H;
			Hs.permute_col(permutation_first);

			permutation_second = Matrix<int>(1, n, 'N'); // Vector_ext::natual<n>(permutation_second);
			Hs.GJE_4_GF2_right(permutation_second);

			// set Gs = [I_k | P^T]
			for (int i = 0; i < k; ++i) {
				for (int j = k; j < n; ++j) {
					Gs(i, j) = Hs(j - k, i);
				}
			}
			//cout << "Gs" << Gs;
		}

		permutation_all = permutation_first;
		permutation_all.permute(permutation_second);	// combine the two permutation, forming a permutation to obtain MRIPs
		//cout << "permutation_all" << permutation_all;

		r_Gs = r;
		r_Gs.permute(permutation_all);			// remember this is a new permutation, all vectors should be re-freshed
		r_abs_Gs = r_abs;
		r_abs_Gs.permute(permutation_all);	// absence of this line cause my first problem, mark down here
		y_Gs = y;
		y_Gs.permute(permutation_all);
		//cout << "r_Gs" << r_Gs;
	}

	// the decoding result is 'c_hat', which can be fetched from the class
	void solve(const Matrix<my_double>& r) {

		TEP_num = 0;
		is_early_termination = false;
		w_min = 3e5;															// initialize to a super large number

		scale_by_sigma = 2 / (sigma * sigma);
		is_GE_skip = false;

		if (condition_1_on_the_fly(r) == true) {
			if (non_GE_OSD(r) == true) {
				//cout << " .. " << endl;
				is_GE_skip = true;
				return;
			}
		}

		/*if (w_min != 3e10 && w_min!= 0) {
			cout << "w_min = " << w_min << endl;
		}*/

		y_bar = y;
		y_bar.permute(permutation_first);										// y.permute(permutation_first, y_bar);

		if (by_generator == true) {
			Gs = G;
			Gs.permute_col(permutation_first);
			// G.permute_column(permutation_first, Gs);

			permutation_second = Matrix<int>(1, n, 'N'); // Vector_ext::natual<n>(permutation_second);
			//Gs.GJE_4_GF2_left(permutation_second);

			Gs.GE_left_identity_match_jiabao(permutation_second);
			//cout << "Gs" << Gs;
		}
		else {
			Hs = H;
			Hs.permute_col(permutation_first);

			permutation_second = Matrix<int>(1, n, 'N'); // Vector_ext::natual<n>(permutation_second);
			//Hs.GJE_4_GF2_right(permutation_second);

			Hs.GE_right_identity_match_jiabao(permutation_second);

			// set Gs = [I_k | P^T]
			for (int i = 0; i < k; ++i) {
				for (int j = k; j < n; ++j) {
					Gs(i, j) = Hs(j - k, i);
				}
			}
			//cout << "Gs" << Gs;
		}

		permutation_all = permutation_first;
		permutation_all.permute(permutation_second);	// combine the two permutation, forming a permutation to obtain MRIPs
		//cout << "permutation_all" << permutation_all;

		r_Gs = r;
		r_Gs.permute(permutation_all);			// remember this is a new permutation, all vectors should be re-freshed
		r_abs_Gs = r_abs;
		r_abs_Gs.permute(permutation_all);	// absence of this line cause my first problem, mark down here
		y_Gs = y;
		y_Gs.permute(permutation_all);
		//cout << "r_Gs" << r_Gs;


		//cout << "my_double_auxiliary_storage::operation_number (1) = " << my_double_auxiliary_storage::operation_number << endl;

		//y_Gs.get_part<k>(0, k - 1, yB_Gs);
		//cout << "y_Gs" << y_Gs;
		//cout << "yB_Gs" << yB_Gs;

		cb_Gs_need_permute_back = false;
		//c0_Gs = yB_Gs * Gs;
		first_re_encoding();
		//cout << "c0_Gs" << c0_Gs;
		my_double w_c0_Gs = soft_Hamming_weight(c0_Gs);
		if (w_c0_Gs < w_min) {

			w_min = w_c0_Gs;
			cb_Gs = c0_Gs;
			cb_Gs_need_permute_back = true;
			//cout << "w_min = " << w_min << endl;

			//cout << "cb_Gs" << cb_Gs;

			//cout << "my_double_auxiliary_storage::operation_number (2) = " << my_double_auxiliary_storage::operation_number << endl;

			if (phase_0_termination() == true) {
				return;
			}
		}
		

		//cout << "my_double_auxiliary_storage::operation_number (3) = " << my_double_auxiliary_storage::operation_number << endl;

		//cout << "c0_Gs" << c0_Gs;
		//cout << "d_min = " << d_min << endl;

		//cout << "G_threshold_component" << G_threshold_component;
		//cout << "G_threshold = " << G_threshold << endl;


		for (int i = 1; i <= order; ++i) {
			TEP_generator.set_weight(i);

			if (new_order_termination(i) == true) {
				return;
			}


			while (TEP_generator.now[0] >= 0) {

				//cout << "TEP_generator.now" << TEP_generator.now;

				re_encoding(TEP_generator.now);

				//cout << "ce_Gs" << ce_Gs;
				w_ce_Gs = soft_Hamming_weight(ce_Gs);
				//cout << "w_ce_Gs = " << w_ce_Gs << endl;

				if (w_ce_Gs < w_min) {
					w_min = w_ce_Gs;
					cb_Gs = ce_Gs; 
					cb_Gs_need_permute_back = true;

					if (optimal_termination(i) == true) {
						return;
					}
				}
				TEP_generator.next();
			}
		}

		//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;

		//cout << "cb_Gs" << cb_Gs;
		c_hat = cb_Gs;
		if (cb_Gs_need_permute_back == true) {
			c_hat.permute_back(permutation_all);
		}
		return;
	}

	void first_re_encoding() {
		// re-encode 'yB_Gs' into 'c0_Gs', i.e., c0_Gs = yB_Gs * Gs;

		// reset to all-0 vector
		c0_Gs.reset(0);

		for (int j = 0; j < k; ++j) {

			if (y_Gs[j] == 1) {		// consider to write it as 'yB_Gs[j] + 1 == 0' for counting one GF2 operation

				// copy systematic part
				c0_Gs[j] = y_Gs[j];

				// re-encode parity-check part
				int row_start_ind = j * n;
				for (int p = k; p < n; ++p) {
					c0_Gs[p] += Gs[row_start_ind + p];		// add accumulately, this cause my second problem, mark down here
				}
			}

		}

		TEP_num++;
	}

	void re_encoding(const Matrix<int>& TEP_now) {
		// re-encode to ce_Gs

		// initialize ans
		for (int i = 0; i < n; ++i) {
			ce_Gs[i] = c0_Gs[i];
		}

		for (int j = 0; j < TEP_now.size(); ++j) {
			// flip systematic part
			ce_Gs[TEP_now[j]] += 1;

			// re-encode parity-check part
			int row_start_ind = TEP_now[j] * n;
			for (int p = k; p < n; ++p) {
				ce_Gs[p] += Gs[row_start_ind + p];		// add accumulately, this cause my second problem, mark down here
			}
		}

		TEP_num++;
	}

	my_double soft_Hamming_weight(const Matrix<GF2>& c_Gs) {
		my_double ans = 0;
		error_num = 0;
		for (int i = 0; i < n; ++i) {
			if (c_Gs[i] != y_Gs[i]) {
				ans += r_abs_Gs[i];
				error_num++;
			}
		}
		return ans;
	}

	bool check_ML_codeword_general() {
		// Will always check cb_Gs		
		// 'G_threshold(c_Gs,d)' is only needed to compute


		// Only need 'D0_add_size' reliabilities adding up to form the 'G_threshold'
		int D0_add_size = min_Hamming_distance - error_num;

		// This re-arrange the codeword candidate in decreasing reliability. If not, will not guarantee an ML codeword
		cb_bar = cb_Gs;
		cb_bar.permute_back(permutation_second);

		G_threshold = 0;

		for (int i = n - 1; i >= 0 && D0_add_size > 0; --i) {

			if (cb_bar[i] == y_bar[i]) {		// 'D0' set, traverse starting from the least reliable position
				G_threshold += r_abs_bar[i];
				D0_add_size--;

				//if (w_min < G_threshold) return true;		// in align with Guo's Program
			}
		}
		return (w_min < G_threshold);
		//return false;		// ML criterion for general codeword
	}

	bool check_ML_codeword_OSD_specific(int TEP_weight) {
		// Will always check cb_Gs		
		// 'G_threshold(c_Gs,d)' is only needed to compute

		G_threshold = G_OSD_threshold;
		/*for (int i = 0; i < TEP_weight; ++i) {
			G_threshold += r_abs_Gs[k - 1 - i];
		}*/

		// Only need 'D0_add_size' reliabilities adding up to 'G_threshold' further form the entire 'G_threshold'
		int D0_add_size = min_Hamming_distance - error_num - TEP_weight;

		// This re-arrange the codeword candidate in decreasing reliability. If not, will not guarantee an ML codeword
		cb_bar = cb_Gs;
		cb_bar.permute_back(permutation_second);

		G_threshold_component.clear();

		for (int i = n - 1; i >= 0 && D0_add_size > 0; --i) {

			if (cb_bar[i] == y_bar[i]) {		// 'D0' set, traverse starting from the least reliable position
				G_threshold += r_abs_bar[i];
				D0_add_size--;

				//if (w_min < G_threshold) return true;		// in align with Guo
				G_threshold_component.push_back(r_abs_bar[i]);
			}
		}
		return (w_min < G_threshold);
		//return false;		// ML criterion for general codeword
	}

	bool check_ML_codeword_OSD_new_phase(int phase_num) {

		//cout << "r_abs_Gs" << r_abs_Gs;
		//cout << "r_abs_Gs[k - phase_num] = " << r_abs_Gs[k - phase_num] << endl;

		// update 'G_threshold' for a new judgement
		if (!G_threshold_component.empty()) {

			G_threshold += r_abs_Gs[k - phase_num] - G_threshold_component.back();
			G_threshold_component.pop_back();
		}
		else {
			G_threshold += r_abs_Gs[k - phase_num];
		}

		// judge the current best codeword if it is ML
		if (w_min < G_threshold) {
			return true;
		}
		else {
			// update 'G_OSD_threshold' for the following codeword candidates
			G_OSD_threshold += r_abs_Gs[k - phase_num];
			return false;
		}
	}

	void G_threshold_OS_OSD_ini() {
		G_threshold = 0;

		for (int i = k; i < n; ++i) {
			G_threshold += r_abs_Gs(i) / (1 + exp(scale_by_sigma * r_abs_Gs(i)));
		}
	}

	void G_threshold_OS_OSD_increase(int phase_num) {
		G_threshold += r_abs_Gs(k - phase_num);
	}

	bool check_codeword_OS_OSD() {
		// Will always check cb_Gs		

		return w_min < G_threshold;
	}

	void early_termination() {
		c_hat = cb_Gs;
		c_hat.permute_back(permutation_all);
		is_early_termination = true;
		return;
	}

	bool phase_0_termination() {
		if (ET_type == 1) {
			if (check_ML_codeword_general() == true) {		// in order-0, this is the same as the OSD specific type			
				early_termination();
				return true;
			}
		}
		else if (ET_type == 2) {
			G_OSD_threshold = 0;

			if (check_ML_codeword_OSD_specific(0) == true) {		// in order-0, this is the same as the OSD specific type			
				early_termination();
				return true;
			}
		}
		else if (ET_type == 3) {

			G_threshold_OS_OSD_ini();
			if (check_codeword_OS_OSD() == true) {		// use order-skipping ET in order-0				
				early_termination();
				return true;
			}
		}
		return false;
	}

	bool new_order_termination(int i) {
		if (ET_type == 2) {
			if (check_ML_codeword_OSD_new_phase(i) == true) {
				early_termination();
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
				return true;
			}
		}
		else if (ET_type == 3) {
			G_threshold_OS_OSD_increase(i);
			if (check_codeword_OS_OSD() == true) {
				early_termination();
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
				return true;
			}
		}
		return false;
	}

	bool optimal_termination(int i) {
		if (ET_type == 1) {
			if (check_ML_codeword_general() == true) {
				early_termination();
				return true;
			}
		}
		else if (ET_type == 2) {
			if (check_ML_codeword_OSD_specific(i) == true) {		// it actually is an ML criterion even for LLOSD		
				early_termination();
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
				return true;
			}
		}
		else if (ET_type == 3) {
			if (check_codeword_OS_OSD() == true) {
				early_termination();
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
				return true;
			}
		}
		return false;
	}
};