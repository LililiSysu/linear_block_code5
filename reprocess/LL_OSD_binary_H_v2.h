#pragma once
/*****************************************************************//**
 * \file   LL_OSD_binary_H_v2.h
 * \brief  LLOSD that extend generator matrix into binary form
 *
 * \author 26259
 * \date   March 2024
 *********************************************************************/

#include"OSD.h"
#include"../code/RS.h"
#include"../code/BCH.h"
#include"../Viterbi/Viterbi_advanced.h"

 // only for binary primitive narrow-sence BCH codes
template<int m, int t>
class LL_OSD_binary_H_v2 {
protected:

	RS<m, (1 << m) - 1 - 2 * t> rs;
	BCH<m, t> bch;
	int n;
	int k;
	int k_prime;
	int min_Hamming_distance;

	// variables during decoding
	Matrix<int> r_abs_Gs_record;			// Permutation for obtaining MRIPs
	Matrix<GF2> y;						// Hard-decisions of received vector
	Matrix<my_double> r_abs;				// Received vector in absolute value
	Matrix<my_double> r_Gs;			// Permuted received vector
	Matrix<my_double> r_abs_Gs;		// Permuted received vector in absolute value

	Matrix<GF2e<m>> Gs;					// Systematic generator matrix corresponding to MRIPs, non-binary
	Matrix<GF2e<m>> P;				// Parity part of Gs, non-binary
	Matrix<GF2> P_ext;				// Binary extension of P
	Matrix<GF2> P1;					// Upper part of P_ext
	Matrix<GF2> P2;					// Lower part of P_ext
	//Matrix<GF2> Gs_k_prime;					// Systematic generator matrix corresponding to k' MRPs, binary, [I | P1.Transpose()]
	Matrix<int> P1_row_ind;			// Constant vector as [0,m,2m, ... (n - k_prime - 1) * m], denote the rows of P_ext that constitute P1

	Matrix<GF2> y_Gs;					// Permuted hard-decisions of received vector

	//Matrix<GF2> c0_Gs_B;					// First permuted codeword candidate, MRP part
	Matrix<GF2> c0_Gs_check_ref;			// c0_Gs_B * P2^T
	Matrix<GF2> c0_Gs;					// First permuted codeword candidate
	Matrix<GF2> cb_Gs;					// The best permuted codeowrd candidate
	my_double w_min;							// Minimum sort Hamming weight that is recorded through re-encoding
	OSD_TEP TEP_generator;				// TEP 'TEP_generator.now' will be generated sequentially
	OSD_TEP_seg TEP_generator_seg;				// TEP 'TEP_generator_seg.now' will be generated sequentially, using segmented order
	Matrix<GF2> ce_Gs;					// Permuted codeowrd candidate generated by TEP 'TEP_generator.now'
	my_double w_ce_Gs;						// Sort Hamming weight of 'ce_Gs'
	int error_num;								// Number of different bits between 'y_Gs' and 'ce_Gs' ( 'c0_Gs' when in phase-0 )

	my_double G_threshold;					// threshold for ML criterion
	Matrix<my_double> G_OSD_threshold;				// the i-th element is the soft Hamming weight lower bound for OSD phase-i re-processing
	Matrix<my_double> G_threshold_component;	// store r_abs_bar values adding in that constitute G_threshold

	Matrix<int> permutation_first;		// Permutation that ensures decreasing reliability
	Matrix<int> info_set_rs;			// RS MRB, first 'k' entries of 'permutation_first'

	bool current_codeword_binary;		// if true, re-encode into a binary codeword
	Matrix<int> row_add_index;			// the rows to add for re-encoding
	Matrix<int> sys_order_inv;			// inverse permutation of 'sys_order' below
	Matrix<int> sys_order;				// map the re-encoding TEP into rows in Gs

public:
	int order;
	int second_order;
	Matrix<GF2> c_hat;					// Optimal codeword for output
	int type;
	Matrix<int> seg_weight_sequence;		// the sequence that the weight of 'TEP_generator_seg' will follow

	// simulation statistics
	int TEP_num;						// number of TEP used for re-encoding
	bool is_early_termination;			// if ture, the decoding is terminated by stopping condition
	bool has_codeword_binary;			// if ture, already have a binary codeword, this is actually used in decoding
	int binary_codeword_num;			// number of binary BCH codeword generated

	// interface
	my_double sigma;					// denote the received signal noise, keep for order-skipping condition
	int ET_type;						// 0 -> no stopping criterion; 1 -> general ML stopping criterion; 
										// 2 -> OSD specific ML stopping criterion; 3 -> OS stopping cirterion

	LL_OSD_binary_H_v2(int _order, int _second_order = 0) : TEP_generator(rs.get_k()), TEP_generator_seg(bch.get_k(), rs.get_k() - bch.get_k()) {

		n = (1 << m) - 1;
		k = bch.get_k();
		k_prime = n - 2 * t;

		min_Hamming_distance = bch.get_d();
		order = _order;
		second_order = _second_order;
		r_abs.resize(1, n);
		y.resize(1, n);
		//c0_Gs_B.resize(1, k_prime);
		c0_Gs.resize(1, n);
		ce_Gs.resize(1, n);
		c_hat.resize(1, n);
		row_add_index.resize(1, k_prime);

		// initialize to arbitary values
		w_min = 0;
		w_ce_Gs = 0;
		error_num = 0;
		G_threshold = 0;
		G_OSD_threshold.resize(1, order + second_order + 1);		// the only constraint for second_order
		G_OSD_threshold(0) = 0;

		current_codeword_binary = false;
		has_codeword_binary = false;

		if (second_order == 0) {
			cout << "LL_OSD_binary_H_v2(" << order << ")" << endl;
			type = 12;
		}
		else {
			cout << "LL_OSD_binary_H_v2_seg(" << order<<", "<< second_order << ")" << endl;
			type = 13;
		}

		TEP_num = 0;
		is_early_termination = false;
		binary_codeword_num = 0;

		P1_row_ind = Matrix<int>(0, m, (n - k_prime - 1) * m, 'd');

		sigma = 0;				// reset arbitary, need to change with the channel SNR
		ET_type = 3;			// the most efficient and non-significant performance loss ET
	}

	void call_GE_only(const Matrix<my_double>& r) {
		for (int i = 0; i < n; ++i) {
			r_abs[i] = my::abs(r[i]);
			y[i] = r[i] > 0 ? 0 : 1;
		}
		permutation_first = Matrix<int>(1, n, 'N');								// Vector_ext::natual<n>(permutation_first);


		r_abs_Gs = r_abs;
		r_abs_Gs.quick_sort_recur_gt_with_ind(0, n - 1, permutation_first);	// r_abs.sort_gt_with_record(permutation_first, r_abs_bar);

		info_set_rs = permutation_first.get_part(0, 0, 0, k_prime - 1);
		rs.generate_systematic_generator_any_pos_best(info_set_rs);

		// adding new lines for parallarization count

		Gs = rs.generator_M_systematic_any_pos;
		Gs.permute_col(permutation_first);
		// G.permute_column(permutation_first, Gs);

		// get P1 and P2 from parity part of Gs
		P = Gs.get_part(0, k_prime, -1, -1).Transpose();
		P_ext = GF2e<m>::to_bits_row_extention(P);
		P1 = P_ext.get_rows(P1_row_ind);
		P2 = P_ext.erase_rows(P1_row_ind, true);				// remember Gs_k_prime =  [I | P1.Transpose()]

		//Gs_k_prime = Matrix<GF2>(k_prime, k_prime, 'i').combine_right(P1.Transpose());			// actually not necessary in re-encoding, we can use P1 only

		//cout << "Gs" << Gs;
		//cout << "P" << P;
		//cout << "P_ext" << P_ext;
		//cout << "P1" << P1;
		//cout << "P2" << P2;

		r_Gs = r;
		r_Gs.permute(permutation_first);
		//cout << "r_Gs" << r_Gs;

		y_Gs = y;
		y_Gs.permute(permutation_first);										// y.permute(permutation_first, y_bar);
		//cout << "y_Gs" << y_Gs;

		// find the permutation on P2 for checking
		/*Matrix<GF2e<m>> y_Gs_e(1, n);
		for (int i = 0; i < n; ++i) {
			y_Gs_e(i) = y_Gs(i);
		}
		Matrix<GF2e<m>> Hs = P.combine_right(Matrix<GF2e<m>>(n - k_prime, n - k_prime,'i'));
		cout << "Hs" << Hs;
		cout << "y_Gs_e" << y_Gs_e;
		cout << "y_Gs_e.multiply_transpose_of(Hs)" << y_Gs_e.multiply_transpose_of(Hs);
		cout << "------" << endl;
		Hs.permute_col(sys_order);			// vital permutation
		cout << "y_Gs_e" << y_Gs_e;
		cout << "y_Gs_e.multiply_transpose_of(Hs)" << y_Gs_e.multiply_transpose_of(Hs);*/

		P2.permute_col(sys_order);
	}

	// the decoding result is 'c_hat', which can be fetched from the class
	void solve(const Matrix<my_double>& r) {
		for (int i = 0; i < n; ++i) {
			r_abs[i] = my::abs(r[i]);
			y[i] = r[i] > 0 ? 0 : 1;
		}
		permutation_first = Matrix<int>(1, n, 'N');								// Vector_ext::natual<n>(permutation_first);


		r_abs_Gs = r_abs;
		r_abs_Gs.quick_sort_recur_gt_with_ind(0, n - 1, permutation_first);	// r_abs.sort_gt_with_record(permutation_first, r_abs_bar);

		info_set_rs = permutation_first.get_part(0, 0, 0, k_prime - 1);

		// record re-encoding rows, pay attention to write comments
		sys_order_inv = info_set_rs.sort_with_ind('<');
		// find the inverse of 'sys_order_inv', that is re-encoding rows order
		sys_order = Matrix<int>(1, k_prime, 'N');
		sys_order.permute_back(sys_order_inv);
		//cout << "sys_order = " << sys_order;

		rs.generate_systematic_generator_any_pos_best(info_set_rs);

		Gs = rs.generator_M_systematic_any_pos;
		Gs.permute_col(permutation_first);
		// G.permute_column(permutation_first, Gs);

		// get P1 and P2 from parity part of Gs
		P = Gs.get_part(0, k_prime, -1, -1).Transpose();
		P_ext = GF2e<m>::to_bits_row_extention(P);
		P1 = P_ext.get_rows(P1_row_ind);
		P2 = P_ext.erase_rows(P1_row_ind, true);				// remember Gs_k_prime =  [I | P1.Transpose()]

		//Gs_k_prime = Matrix<GF2>(k_prime, k_prime, 'i').combine_right(P1.Transpose());			// actually not necessary in re-encoding, we can use P1 only

		//cout << "Gs" << Gs;
		//cout << "P" << P;
		//cout << "P_ext" << P_ext;
		//cout << "P1" << P1;
		//cout << "P2" << P2;

		r_Gs = r;
		r_Gs.permute(permutation_first);
		//cout << "r_Gs" << r_Gs;

		y_Gs = y;
		y_Gs.permute(permutation_first);										// y.permute(permutation_first, y_bar);
		//cout << "y_Gs" << y_Gs;

		// find the permutation on P2 for checking
		/*Matrix<GF2e<m>> y_Gs_e(1, n);
		for (int i = 0; i < n; ++i) {
			y_Gs_e(i) = y_Gs(i);
		}
		Matrix<GF2e<m>> Hs = P.combine_right(Matrix<GF2e<m>>(n - k_prime, n - k_prime,'i'));
		cout << "Hs" << Hs;
		cout << "y_Gs_e" << y_Gs_e;
		cout << "y_Gs_e.multiply_transpose_of(Hs)" << y_Gs_e.multiply_transpose_of(Hs);
		cout << "------" << endl;
		Hs.permute_col(sys_order);			// vital permutation
		cout << "y_Gs_e" << y_Gs_e;
		cout << "y_Gs_e.multiply_transpose_of(Hs)" << y_Gs_e.multiply_transpose_of(Hs);*/

		P2.permute_col(sys_order);

		//cout << "my_double_auxiliary_storage::operation_number (1) = " << my_double_auxiliary_storage::operation_number << endl;
		//cout << "GF2e_auxiliary_storage::operation_number (1) = " << GF2e_auxiliary_storage::operation_number << endl;

		//y_Gs.get_part<k>(0, k - 1, yB_Gs);
		//cout << "yB_Gs" << yB_Gs;

		TEP_num = 0;
		is_early_termination = false;
		binary_codeword_num = 0;

		//c0_Gs = yB_Gs * Gs;
		first_re_encoding();
		//cout << "c0_Gs" << c0_Gs;

		if (current_codeword_binary == true) {

			w_min = soft_Hamming_weight(c0_Gs);
		}
		else {
			w_min = 3e10;		// a super large number
		}
		//cout << "w_min = " << w_min << endl;

		cb_Gs = c0_Gs;
		//cout << "cb_Gs" << cb_Gs;

		//cout << "my_double_auxiliary_storage::operation_number (2) = " << my_double_auxiliary_storage::operation_number << endl;
		//cout << "GF2e_auxiliary_storage::operation_number (2) = " << GF2e_auxiliary_storage::operation_number << endl;

		if (phase_0_termination() == true) {
			return;
		}

		//cout << "my_double_auxiliary_storage::operation_number (3) = " << my_double_auxiliary_storage::operation_number << endl;
		//cout << "GF2e_auxiliary_storage::operation_number (3) = " << GF2e_auxiliary_storage::operation_number << endl;

		//cout << "c0_Gs" << c0_Gs;
		//cout << "d_min = " << d_min << endl;

		//cout << "G_threshold_component" << G_threshold_component;
		//cout << "G_threshold = " << G_threshold << endl;

		if (second_order == 0) {
			// using typical order

			for (int i = 1; i <= order; ++i) {
				TEP_generator.set_weight(i);

				if (new_order_termination(i) == true) {
					return;
				}

				while (TEP_generator.now[0] >= 0) {

					//cout << "TEP_generator.now" << TEP_generator.now;

					re_encoding(TEP_generator.now);

					//cout << "ce_Gs" << ce_Gs;

					if (current_codeword_binary == true) {

						w_ce_Gs = soft_Hamming_weight(ce_Gs);
						//cout << "w_ce_Gs = " << w_ce_Gs << endl;

						if (w_ce_Gs < w_min) {
							w_min = w_ce_Gs;
							cb_Gs = ce_Gs;

							if (optimal_termination(i) == true) {
								return;
							}
						}
					}

					TEP_generator.next();
				}
			}
		}
		else {
			// using segmented order

			// follow the 'seg_weight_sequence' to decide the weight of TEPs

			int seg_weight_sequence_row = seg_weight_sequence.row();
			for (int i = 0; i < seg_weight_sequence_row; ++i) {

				TEP_generator_seg.set_weight(seg_weight_sequence(i, 0), seg_weight_sequence(i, 1));

				if (new_order_termination(TEP_generator_seg.seg_1_w + TEP_generator_seg.seg_2_w) == true) {
					return;
				}

				while (TEP_generator_seg.now[0] >= 0) {

					//cout << "TEP_generator_seg.now" << TEP_generator_seg.now;

					re_encoding(TEP_generator_seg.now);

					//cout << "ce_Gs" << ce_Gs;
					if (current_codeword_binary == true) {

						w_ce_Gs = soft_Hamming_weight(ce_Gs);
						//cout << "w_ce_Gs = " << w_ce_Gs << endl;

						if (w_ce_Gs < w_min) {
							w_min = w_ce_Gs;
							cb_Gs = ce_Gs;

							if (optimal_termination(TEP_generator_seg.seg_1_w + TEP_generator_seg.seg_2_w) == true) {
								return;
							}								
						}
					}

					TEP_generator_seg.next();
				}
			}
		}

		//cout << "my_double_auxiliary_storage::operation_number (5) = " << my_double_auxiliary_storage::operation_number << endl;
		//cout << "GF2e_auxiliary_storage::operation_number (5) = " << GF2e_auxiliary_storage::operation_number << endl;

		//cout << "cb_Gs" << cb_Gs;
		c_hat = cb_Gs;
		c_hat.permute_back(permutation_first);
		return;
	}

	void first_re_encoding() {

		TEP_num++;

		// re-encode 'yB_Gs' into 'c0_Gs', i.e., c0_Gs = yB_Gs * Gs;

		// reset to all-0 vector
		c0_Gs.reset(0);
		row_add_index.clear();

		for (int j = 0; j < k_prime; ++j) {

			if (y_Gs[j] == 1) {		// consider to write it as 'yB_Gs[j] + 1 == 0' for counting one GF2 operation

				// copy systematic part
				c0_Gs[j] = y_Gs[j];

				row_add_index.push_back(j);
			}
		}

		// re-encode parity-check part
		for (int p = k_prime; p < n; ++p) {
			int row_add_num = row_add_index.size();
			for (int i = 0; i < row_add_num; ++i) {
				// be careful that Gs_k_prime =  [I | P1.Transpose()]
				c0_Gs[p] += P1(p - k_prime, sys_order(row_add_index(i)));		// add accumulately, this cause my second problem, mark down here
			}
		}


		// judeg if c0_Gs is BCH code, that is to jude if c0_Gs can pass parity-check matrix P2
		c0_Gs_check_ref = P2.sum_columns(row_add_index);
		//cout << "row_add_index" << row_add_index;
		//cout << "P2" << P2;
		//cout << "c0_Gs_check_ref" << c0_Gs_check_ref;
		//cout << "c0_Gs.get_part(0, 0, 0, k_prime - 1).multiply_transpose_of(P2) = " << c0_Gs.get_part(0, 0, 0, k_prime - 1).multiply_transpose_of(P2);	// problem here
		current_codeword_binary = false;
		if (c0_Gs_check_ref.isZero() == true) {
			current_codeword_binary = true;
			binary_codeword_num++;
		}
		has_codeword_binary = current_codeword_binary;
	}

	void re_encoding(const Matrix<int>& TEP_now) {
		TEP_num++;

		// judge if the TEP_now can satisfy parity-check matrix P2
		if (P2.sum_columns_is_ref(TEP_now, c0_Gs_check_ref) == false) {
			// not a valid TEP, quit re-encoding

			current_codeword_binary = false;
			return;
		}

		// re-encode to ce_Gs

		// initialize ans
		ce_Gs = c0_Gs;

		int row_add_num = TEP_now.size();
		for (int j = 0; j < row_add_num; ++j) {
			// flip systematic part
			ce_Gs[TEP_now[j]] += GF2(1);		// flip the binary bit
		}

		// re-encode parity-check part
		for (int p = k_prime; p < n; ++p) {
			for (int i = 0; i < row_add_num; ++i) {
				ce_Gs[p] += P1(p - k_prime, sys_order(TEP_now(i)));		// add accumulately, this cause my second problem, mark down here
			}
		}

		current_codeword_binary = true;
		has_codeword_binary = true;
		binary_codeword_num++;
	}

	my_double soft_Hamming_weight(const Matrix<GF2>& c_Gs) {
		my_double ans = 0;
		error_num = 0;
		for (int i = 0; i < n; ++i) {
			if (c_Gs[i] != y_Gs[i]) {
				ans += r_abs_Gs[i];
				error_num++;
			}
		}
		return ans;
	}

	bool check_ML_codeword_general() {
		// Will always check cb_Gs		
		// 'G_threshold(c_Gs,d)' is only needed to compute

		// Only need 'D0_add_size' reliabilities adding up to form the 'G_threshold'
		int D0_add_size = min_Hamming_distance - error_num;

		// This re-arrange the codeword candidate in decreasing reliability. If not, will not guarantee an ML codeword

		G_threshold = 0;

		for (int i = n - 1; i >= 0 && D0_add_size > 0; --i) {

			if (cb_Gs[i] == y_Gs[i]) {		// 'D0' set, traverse starting from the least reliable position
				G_threshold += r_abs_Gs[i];
				D0_add_size--;

				//if (w_min < G_threshold) return true;		// in align with Guo's program
			}
		}
		return (w_min < G_threshold);
		//return false;		// ML criterion for general codeword
	}

	void G_OSD_threshold_ini() {
		int n = G_OSD_threshold.size();
		for (int i = 1; i < n; ++i) {
			G_OSD_threshold(i) = G_OSD_threshold(i - 1) + r_abs_Gs[k_prime - i];
		}
	}

	bool check_ML_codeword_OSD_new_phase(int phase_num) {

		//cout << "r_abs_Gs" << r_abs_Gs;
		//cout << "r_abs_Gs[k - phase_num] = " << r_abs_Gs[k - phase_num] << endl;

		// update 'G_threshold' for a new judgement
		if (!G_threshold_component.empty()) {

			G_threshold += r_abs_Gs[k_prime - phase_num] - G_threshold_component.back();
			G_threshold_component.pop_back();
		}
		else {
			G_threshold += r_abs_Gs[k_prime - phase_num];
		}

		// judge the current best codeword if it is ML
		if (w_min < G_threshold) {
			return true;
		}
		else {
			return false;
		}
	}

	bool check_ML_codeword_OSD_specific(int TEP_weight) {
		// Will always check cb_Gs		
		// 'G_threshold(c_Gs,d)' is only needed to compute

		G_threshold = G_OSD_threshold(TEP_weight);
		/*for (int i = 0; i < TEP_weight; ++i) {
			G_threshold += r_abs_Gs[k - 1 - i];
		}*/

		// Only need 'D0_add_size' reliabilities adding up to 'G_threshold' further form the entire 'G_threshold'
		int D0_add_size = min_Hamming_distance - error_num - TEP_weight;

		// This re-arrange the codeword candidate in decreasing reliability. If not, will not guarantee an ML codeword

		G_threshold_component.clear();

		for (int i = n - 1; i >= 0 && D0_add_size > 0; --i) {

			if (cb_Gs[i] == y_Gs[i]) {		// 'D0' set, traverse starting from the least reliable position
				G_threshold += r_abs_Gs[i];
				D0_add_size--;

				//if (w_min < G_threshold) return true;		// in align with Guo
				G_threshold_component.push_back(r_abs_Gs[i]);
			}
		}
		return (w_min < G_threshold);
		//return false;		// ML criterion for general codeword
	}

	void G_threshold_OS_OSD_ini() {
		G_threshold = 0;

		my_double scale_by_sigma = 2 / (sigma * sigma);
		for (int i = k_prime; i < n; ++i) {
			G_threshold += r_abs_Gs(i) / (1 + exp(scale_by_sigma * r_abs_Gs(i)));		// omit the complexity of 'exp'
		}
	}

	bool check_codeword_OS_OSD(int phase_num) {
		// Will always check cb_Gs		

		return w_min < G_threshold + G_OSD_threshold(phase_num);
	}

	void early_termination() {
		c_hat = cb_Gs;
		c_hat.permute_back(permutation_first);
		is_early_termination = true;
		return;
	}

	bool phase_0_termination() {
		if (ET_type == 1) {
			if (has_codeword_binary == true && check_ML_codeword_general() == true) {		// in order-0, this is the same as the OSD specific type			
				early_termination();
				return true;
			}
		}
		else if (ET_type == 2) {

			G_OSD_threshold_ini();

			if (has_codeword_binary == true && check_ML_codeword_OSD_specific(0) == true) {		// in order-0, this is the same as the OSD specific type			
				early_termination();
				return true;
			}
		}
		else if (ET_type == 3) {

			G_OSD_threshold_ini();
			G_threshold_OS_OSD_ini();

			if (has_codeword_binary == true && check_codeword_OS_OSD(0) == true) {		// use order-skipping ET in order-0				
				early_termination();
				return true;
			}
		}
		return false;
	}

	bool new_order_termination(int i) {
		if (ET_type == 2) {
			if (has_codeword_binary == true && check_ML_codeword_OSD_new_phase(i) == true) {
				early_termination();
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
				return true;
			}
		}
		else if (ET_type == 3) {
			if (has_codeword_binary == true && check_codeword_OS_OSD(i) == true) {
				early_termination();
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
				return true;
			}
		}
		return false;
	}

	bool optimal_termination(int i) {
		if (ET_type == 1) {
			if (has_codeword_binary == true && check_ML_codeword_general() == true) {
				early_termination();
				return true;
			}
		}
		else if (ET_type == 2) {
			if (has_codeword_binary == true && check_ML_codeword_OSD_specific(i) == true) {		// it actually is an ML criterion even for LLOSD		
				early_termination();
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
				return true;
			}
		}
		else if (ET_type == 3) {
			if (has_codeword_binary == true && check_codeword_OS_OSD(i) == true) {
				early_termination();
				//cout << "my_double_auxiliary_storage::operation_number (4) = " << my_double_auxiliary_storage::operation_number << endl;
				//cout << "GF2e_auxiliary_storage::operation_number (4) = " << GF2e_auxiliary_storage::operation_number << endl;
				return true;
			}
		}
		return false;
	}
};

template<int m,int t>
class LL_OSD_binary_H_hybrid_Viterbi_v2: public LL_OSD_binary_H_v2<m, t>
{
protected:
	
	Viterbi_unordered_map vit;

	/* variable during decoding */
	Matrix<int> random_selected_row_inds;	// row indices of P2 that used in list Viterbi search, the remaining indices are used for parity check, mark again
	Matrix<GF2> P2_new;						// this->P2 after erasing all 0 rows
	Matrix<GF2> P3;							// rows of this->P2 used for list Viterbi search
	Matrix<GF2> P4;							// rows of this->P2 used for parity check
	Matrix<GF2> c_hat_list_Viterbi;			// the decoding result of list Viterbi
	my_double w_c_hat_list_Viterbi;			// soft Hamming weight of 'c_hat_list_Viterbi'

	Matrix<GF2> first_dv;					// re-encoding result of the first List-viterbi search vector
	Matrix<GF2> dv;							// re-encoding result of the List-viterbi search vector
	Matrix<GF2> best_dv;					// best re-encoding result

	void re_encoding_first_dv(const Matrix<GF2>& c_Gs) {

		// re-encode to first_dv

		// initialize ans
		first_dv.reset(0);
		Matrix<int> c_Gs_non_0_ind = c_Gs.get_non_0_ind();
		int row_add_num = c_Gs_non_0_ind.size();

		for (int j = 0; j < row_add_num; ++j) {
			// flip systematic part
			first_dv[c_Gs_non_0_ind[j]] = GF2(1);		// flip the binary bit
		}

		// re-encode parity-check part
		for (int p = this->k_prime; p < this->n; ++p) {
			for (int i = 0; i < row_add_num; ++i) {
				first_dv[p] += this->P1(p - this->k_prime, this->sys_order(c_Gs_non_0_ind(i)));		// add accumulately, this cause my second problem, mark down here
			}
		}
	}

	void re_encoding_dv(const Matrix<int>& flip_ind) {

		// re-encode to dv
		dv = first_dv;

		int row_add_num = flip_ind.size();

		for (int j = 0; j < row_add_num; ++j) {
			// flip systematic part
			dv[flip_ind[j]] += GF2(1);		// flip the binary bit
		}

		// re-encode parity-check part
		for (int p = this->k_prime; p < this->n; ++p) {
			for (int i = 0; i < row_add_num; ++i) {
				dv[p] += this->P1(p - this->k_prime, this->sys_order(flip_ind(i)));		// add accumulately, this cause my second problem, mark down here
			}
		}
	}

public:

	//my_double sigma;			// we must correctly set sigma before decoding, variable included in base class 'LL_OSD_binary_H_v2'
	int selected_row_num;		// number of rows that used in list Viterbi search, the rows are randomly chosen, the left rows are used as parity check
	int max_list_num;			// max number of list number of Viterbi searching

	// simulation statistics, not shown actually, keep for interface consistance
	int ML_used_list_num;


	LL_OSD_binary_H_hybrid_Viterbi_v2(int _flip_order, int _selected_row_num, int _max_list_num) : LL_OSD_binary_H_v2<m, t>(_flip_order) {
		
		selected_row_num = _selected_row_num;
		max_list_num = _max_list_num;

		cout << " -- Hybrid_List_Viterbi(" << selected_row_num << ", " << max_list_num << ")" << endl;
		this->type = 14;

		first_dv.resize(1, this->n);
		dv.resize(1, this->n);
		best_dv.resize(1, this->n);

		w_c_hat_list_Viterbi = 0;
		ML_used_list_num = 0;
		vit.resize(this->k_prime, selected_row_num);
	}

	void solve(const Matrix<my_double>& r) {
		LL_OSD_binary_H_v2<m, t>::solve(r);		// call LL_OSD, flip the MRPs to re-encode candidate codeword
		ML_used_list_num = this->TEP_num;

		if (this->is_early_termination == true) {
			// flip result has passed the 'ML' criterion
			return;		// the returned result will store in this->c_hat
		}

		// removing all-zero rows of 'extend_parity_part'
		P2_new = (this->P2).erase_all_0_rows();

		// start List Viterbi decoding of P2
		//cout << "this->P2" << this->P2;
		random_selected_row_inds = Matrix<int>(1, P2_new.row(), 'N').get_random_element(selected_row_num);
		//cout << "random_selected_row_inds" << random_selected_row_inds;

		P3 = P2_new.get_rows(random_selected_row_inds);
		P4 = P2_new.erase_rows(random_selected_row_inds);


		//cout << "P3" << P3;
		//cout << "P4" << P4;

		//v_hat2 = vit.decode_v_4_LL_OSD_Hybrid_once(, (*this), max_list_num);
		list_Viterbi_search();
		if (best_dv.size() == 0) {
			// not a valid codeowrd found in list Viterbi decoding
			return;
		}

		// compare the soft Hamming weight of 'this->cb_Gs' and 'best_dv' to choose the optimal one
		my_double sw_best_dv = this->soft_Hamming_weight(best_dv);		// the re-computation of soft weight increase some complexity

		//this->w_min = 3e10;						// force to use the result of Viterbi decoding, to be deleted
		if (sw_best_dv < this->w_min) {
			// only in this case list-viterbi change the results of LL_OSD with flipping
			
			//cout << "Changed by List Viterbi" << endl;
			this->c_hat = best_dv;
			this->c_hat.permute_back(this->permutation_first);
			//cout << "this->c_hat" << this->c_hat;
		}

		return;
	}

	void list_Viterbi_search() {

		vit.change_PM(P3);
		vit.change_unused_PM(P4);

		Matrix<my_double> recv_k_prime_part = this->r_Gs.get_part(0, 0, 0, this->k_prime - 1);		// r_L
		Matrix<my_double> recv_redundancy_part = this->r_Gs.get_part(0, this->k_prime, 0, -1);		// r_R

		vit.decode_v_once_inner(recv_k_prime_part, max_list_num);

		//cout << "r_part" << r_part;

		vit.relative_metric.resize(1, max_list_num, false);

		// set for listing
		//Matrix<my_double> r_L = recv_k_prime_part.get_part(0, 0, 0, lc_osd_r.k + lc_osd_r.delta - 1);
		//Matrix<GF2> hdr_R = BPSK::demodulation(recv_redundancy_part);
		Matrix<GF2> hdr_R = this->y_Gs.get_part(0, this->k_prime, 0, -1);

		// it seems problematic
		/*my_double gamma_Z = -Measure::Euclidean_distance(r_part, BPSK::modulation(hdr.get_part(0, 0, 0, lc_osd_r.k + lc_osd_r.delta - 1)));
		my_double gamma_ZL = -Measure::Euclidean_distance(recv_k_prime_part.get_part(0, lc_osd_r.k + lc_osd_r.delta, 0, -1), \
				BPSK::modulation(hdr.get_part(0, lc_osd_r.k + lc_osd_r.delta, 0, -1)));*/

		int r_size = recv_redundancy_part.size();
		//Matrix<my_double> recv_redundancy_part_abs = recv_redundancy_part.get_abs();
		Matrix<my_double> recv_redundancy_part_abs = this->r_abs_Gs.get_part(0, this->k_prime, 0, -1);
		my_double r_abs_minus_1_squared = 0;
		my_double tmp_calculation;
		for (int i = 0; i < r_size; ++i) {
			tmp_calculation = recv_redundancy_part_abs(i) - 1;
			r_abs_minus_1_squared += tmp_calculation * tmp_calculation;
		}

		/*my_double n_plus_sum_r_squared_minus_2_r_abs = r_size;
		for (int i = 0; i < r_size; ++i) {
			n_plus_sum_r_squared_minus_2_r_abs += recv_redundancy_part(i) * recv_redundancy_part(i) - 2 * my::abs(recv_redundancy_part(i));
		}*/

		my_double d_ZR = 0;
		my_double scale_by_sigma = 2 / (this->sigma * this->sigma);
		for (int i = 0; i < r_size; ++i) {
			d_ZR += recv_redundancy_part_abs(i) / (1 + exp(scale_by_sigma * recv_redundancy_part_abs(i)));
		}
		d_ZR *= 4;
		d_ZR += r_abs_minus_1_squared;

		//my_double d_ZR = Measure::Euclidean_distance(recv_redundancy_part, hdr_R, r_abs_minus_1_squared);
		//my_double d_ZL = Measure::Euclidean_distance(r_L, BPSK::modulation(hdr.get_part(0, 0, 0, lc_osd_r.k + lc_osd_r.delta - 1)));

		//cout << "d_Z = " << d_Z << endl;
		//cout << "alpha_minus_1_gamma_ZL = " << alpha_minus_1_gamma_ZL << endl;

		// first not flip any position, for the first set we do demand in v space
		my_double lambda_min = invalid_large_metric;
		my_double d_copt = lambda_min;
		vit.can_v_hat = vit.list_v_hat.get_row(0);
		vit.can_first_v_hat = vit.can_v_hat;
		Matrix<GF2> ref_result;
		if (vit.unused_PM.size() != 0) {
			ref_result = vit.can_v_hat.multiply_transpose_of(vit.unused_PM);		// this can be simplified, to be done
		}
		int best_dv_list_num = max_list_num;
		//cout << "can_v_hat" << can_v_hat;
		//cout << "unused_PM" << unused_PM;

		vit.can_v_hat.permute_back(vit.PM_permutation);

		//cout << "vit.can_v_hat" << vit.can_v_hat;

		// start here to change !!
		re_encoding_first_dv(vit.can_v_hat);


		best_dv.resize(1, 0);
		if (ref_result.isZero()) {

			this->current_codeword_binary = true;
			this->has_codeword_binary = true;
			this->binary_codeword_num++;

			// a valid codeword
			best_dv = first_dv;
			best_dv_list_num = 1;
			//best_dv = can_v_hat.insert_cols(can_v_hat * ll_osd_Hybrid_Viterbi.extend_generator, ll_osd_Hybrid_Viterbi.rs.redundancy_set_ind);
			lambda_min = vit.absolute_metric + vit.absolute_zero_col_mertric + \
				Measure::Euclidean_distance(recv_redundancy_part, best_dv.get_part(0, this->k_prime, 0, -1), r_abs_minus_1_squared);
			d_copt = lambda_min;
		}

		//cout << "best_dv: 0" << best_dv << endl;

		// best_dv after permute back must in v space
		//cout << "lambda_min = " << lambda_min << endl;

		//my_double gamma_C_opt = -lambda_min;
		//cout << "alpha_gamma_C_opt = " << alpha_gamma_C_opt << endl;

		/* assume that if PM is full rank, then there is no need to use unused_PM */

		Matrix<int> flip_ind(1, vit.n_total);

		int used_list_num = 1;
		if (max_list_num > 1) {
			vit.relative_metric(0) = 0;
			//can_opt = priority_queue<metric_point>();
			vit.list_proceed = 0;
			vit.diverge_time = vit.n - 1;
			vit.can_opt_set.clear();
			vit.add_zero_col_pos_2_can_opt_set(max_list_num - 1);

			do {
				vit.next_subopt_v_set(max_list_num - used_list_num);
				my_double d_CL = vit.relative_metric(used_list_num) + vit.absolute_metric + vit.absolute_zero_col_mertric;
				// this is ML		
				if (d_copt < d_CL + d_ZR) {
					/*cout << "break here, i=" << i << endl;
					cout << "d_copt = " << d_copt << endl;
					cout << "d_CL = " << d_CL << endl;*/

					this->TEP_num += (unsigned long long)used_list_num + 1;
					this->is_early_termination = true;
					ML_used_list_num += best_dv_list_num;
					return;
				}

				vit.can_v_hat = vit.list_v_hat.get_row(used_list_num);

				if (vit.unused_PM.check_inner_product_4_GF2(vit.can_v_hat, vit.can_first_v_hat, vit.non_0_ind_aux, ref_result)) {

					this->current_codeword_binary = true;
					this->has_codeword_binary = true;
					this->binary_codeword_num++;

					vit.can_v_hat.permute_back(vit.PM_permutation);

					vit.can_v_hat.diff_ind_inplace(first_dv, flip_ind);		// this is a big problem that cost me a whole day in debuging, mark down here
					re_encoding_dv(flip_ind);

					//cout << "dv" << dv;

					Matrix<GF2> dv_permuted = dv;
					dv_permuted.permute(this->permutation_first);
					//cout << "dv_permuted" << dv_permuted;

					//dv = \
					// can_v_hat.insert_cols(can_v_hat * ll_osd_Hybrid_Viterbi.extend_generator, ll_osd_Hybrid_Viterbi.rs.redundancy_set_ind);

					//my_double gamma_Cr = -Measure::Euclidean_distance(r_part, BPSK::modulation(dv));
					//my_double lambda = Measure::Euclidean_distance(recv, BPSK::modulation(dv));
					my_double lambda = d_CL + Measure::Euclidean_distance(recv_redundancy_part, \
						dv.get_part(0, this->k_prime, 0, -1), r_abs_minus_1_squared);
					//my_double d_C = lambda;

					//cout << "lambda = " << lambda << endl;

					/*cout << "-------- i = " << i << "----------" << endl;
					cout << "d_C = " << d_C << endl;
					cout << "d_copt = " << d_copt << endl;
					cout << "d_C - d_Z = " << d_C - d_Z << " ?> alpha * (d_copt - d_Z) = " << alpha * (d_copt - d_Z) << endl;*/

					//if (gamma_Cr + gamma_ZL < alpha * (gamma_C_opt + gamma_Z)) {
					//	//cout << "break here" << endl;
					//	return best_dv;
					//}

					//my_double beta = 3;
					//if (d_C - d_Z > beta * (d_copt - d_Z)) {
					//	//cout << "break here, i = " << i << endl;
					//	ll_osd_Hybrid_Viterbi.total_used_list_num += i + 1;
					//	return best_dv;
					//}

					if (lambda >= lambda_min);
					else {
						// update best_dv to this erasure decoding result
						best_dv = dv;
						lambda_min = lambda;
						d_copt = lambda_min;
						best_dv_list_num = used_list_num + 1;


						/*cout << "_______________" << endl;
						cout << "used_list_num = " << used_list_num << endl;
						cout << "best_dv" << best_dv;
						cout << "lambda_min = " << lambda_min << endl;
						cout << "_______________" << endl;*/
					}

					/* assume that if PM is full rank, then there is no need to use unused_PM*/
				}
				used_list_num++;
			} while (used_list_num < max_list_num);
			//cout << "relative_metric" << relative_metric;
		}


		this->TEP_num += max_list_num;
		this->is_early_termination = false;
		ML_used_list_num += best_dv_list_num;
	}
};
