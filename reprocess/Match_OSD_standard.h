/*****************************************************************//**
 * \file   Match_OSD.h
 * \brief  New idea of matching TEP according to TEP
 *
 * \author 26259
 * \date   March 2024
 *********************************************************************/

#pragma once

#include"reprocess_common.h"
#include"OSD.h"
#include<unordered_map>
using namespace std;

class Match_OSD_standard {
protected:

	int n;
	int k;
	int min_Hamming_distance;

	Matrix<GF2> Gs;
	Matrix<GF2> Hs;


	Matrix<int> permutation_first;		// Permutation that ensures decreasing reliability
	Matrix<int> permutation_second;		// Permutation that ensures the Gs systematic on left, disrupts decreasing reliability
	Matrix<int> permutation_all;			// Permutation that combines 'permutation_first' and 'permutation_second'

	OSD_TEP TEP_generator;				// TEP 'TEP_generator.now' will be generated sequentially
	bool by_generator;					// if true, use genrator matrix to get its systematic form, else, use parity-check matrix
	Matrix<int> TEP_match;			// the TEP ontained by matching

	/* decoding parameters */
	int order;							// segement order to be implement in the future
	int delta;							// use 'delta' more positions as fake information set
	int k_prime;						// k_prime = k + delta
	int k_shrink;						// k_shrink = k - delta


	/* decoding variables */

	Matrix<GF2> y;						// Hard-decisions of received vector
	Matrix<my_double> r_abs;			// Received vector in absolute value

	Matrix<GF2> y_bar;					// 'y_Gs' without 'permutation_second'
	Matrix<my_double> r_abs_bar;			// 'r_abs' sorted in REAL decreasing reliability, 'r_abs_Gs' without 'permutation_second'


	Matrix<my_double> r_Gs;			// Permuted received vector
	Matrix<my_double> r_abs_Gs;		// Permuted received vector in absolute value
	Matrix<GF2> y_Gs;					// Permuted hard-decisions of received vector
	Matrix<GF2> c0_Gs;					// First permuted codeword candidate
	Matrix<int> c0_Gs_TEP;			// the '1' positions of 'c0_Gs'
	Matrix<GF2> ce_Gs;					// Permuted codeowrd candidate generated by TEP 'TEP_generator.now'
	Matrix<GF2> cb_Gs;					// The best permuted codeowrd candidate


	int error_num;								// Number of different bits between 'y_Gs' and 'ce_Gs' ( 'c0_Gs' when in phase-0 )

	// at most length-64 check bin used, i.e., 'delta' <=64
	unordered_map<unsigned long long, Matrix<Matrix<int>>> delta_check_bin_2_filp_position;	// check bin for flipping TEPs
	unsigned long long target_check_bin;		// delta check bin for the first re-encoding all-0 TEP

public:

	Matrix<GF2> G;
	Matrix<GF2> H;
	int type;
	Matrix<GF2> c_hat;					// Optimal codeword for output

	// simulation statistics
	int TEP_num;						// number of TEP used for re-encoding

	Match_OSD_standard(const Matrix<GF2>& _G, const Matrix<GF2>& _H, int _d, int _order, int _delta \
	) : TEP_generator(delta + (_G.row() <= _H.row() ? _G.row() : _H.col() - _H.row())) {

		by_generator = _G.row() <= _H.row();
		n = by_generator ? _G.col() : _H.col();

		type = 21;
		//cout << "Match_OSD(" << _order << ")" << endl;

		if (by_generator == true) {
			G = _G;
			k = G.row();
		}
		else {
			H = _H;
			k = n - H.row();
			Gs = Matrix<GF2>(k, n, 'i');
		}

		min_Hamming_distance = _d;
		order = _order;

		r_abs.resize(1, n);
		y.resize(1, n);
		c0_Gs.resize(1, n);
		ce_Gs.resize(1, n);

		delta = _delta;
		k_prime = k + delta;
		k_shrink = k - delta;

		// initialize to arbitary values
		TEP_num = 0;
		TEP_match.resize(1, max_OSD_order);
	}

	void solve(const Matrix<my_double>& r) {
		for (int i = 0; i < n; ++i) {
			r_abs[i] = my::abs(r[i]);
			y[i] = r[i] > 0 ? 0 : 1;
		}
		permutation_first = Matrix<int>(1, n, 'N');								// Vector_ext::natual<n>(permutation_first);
		r_abs_bar = r_abs;
		r_abs_bar.quick_sort_recur_gt_with_ind(0, n - 1, permutation_first);	// r_abs.sort_gt_with_record(permutation_first, r_abs_bar);
		y_bar = y;
		y_bar.permute(permutation_first);										// y.permute(permutation_first, y_bar);

		if (by_generator == true) {
			Gs = G;
			Gs.permute_col(permutation_first);
			// G.permute_column(permutation_first, Gs);

			permutation_second = Matrix<int>(1, n, 'N'); // Vector_ext::natual<n>(permutation_second);
			Gs.GJE_4_GF2_left(permutation_second);
		}
		else {
			Hs = H;
			Hs.permute_col(permutation_first);

			permutation_second = Matrix<int>(1, n, 'N'); // Vector_ext::natual<n>(permutation_second);
			Hs.GJE_4_GF2_right(permutation_second);

			// set Gs = [I_k | P^T]
			for (int i = 0; i < k; ++i) {
				for (int j = k; j < n; ++j) {
					Gs(i, j) = Hs(j - k, i);
				}
			}
		}

		//cout << "Gs" << Gs;

		permutation_all = permutation_first;
		permutation_all.permute(permutation_second);	// combine the two permutation, forming a permutation to obtain MRIPs
		//cout << "permutation_all" << permutation_all;

		r_Gs = r;
		r_Gs.permute(permutation_all);			// remember this is a new permutation, all vectors should be re-freshed
		r_abs_Gs = r_abs;
		r_abs_Gs.permute(permutation_all);	// absence of this line cause my first problem, mark down here
		y_Gs = y;
		y_Gs.permute(permutation_all);

		// re-encoding the TEP

		TEP_num = 0;

		// re-encoding the 0-vector
		first_re_encoding();

		// generate the 'target_check_bin'
		target_check_bin = compute_check_bin(c0_Gs_TEP);

		/*cout << "c0_Gs" << c0_Gs;
		cout << "target_check_bin = " << target_check_bin << endl;
		cout << "----------------" << endl;*/

		my_double w_0 = soft_Hamming_weight(c0_Gs);
		//cout << "w_0 = " << w_0 << endl;

		/*c_hat = c0_Gs;
		c_hat.permute_back(permutation_all);
		return;*/

		my_double w_min = 3e10;
		my_double w_can;

		delta_check_bin_2_filp_position.clear();
		delta_check_bin_2_filp_position[0].push_back(Matrix<int>());

		for (int i = 1; i <= order; ++i) {
			TEP_generator.set_weight(i);


			while (TEP_generator.now[0] >= 0) {

				//cout << "TEP_generator.now" << TEP_generator.now;

				//re_encoding(TEP_generator.now);

				unsigned long long check_bin = compute_check_bin(TEP_generator.now);
				delta_check_bin_2_filp_position[check_bin].push_back(TEP_generator.now);


				/*cout << "ce_Gs" << ce_Gs;
				cout << "ce_Gs.multiply_transpose_of(Hs).isZero() = " << ce_Gs.multiply_transpose_of(Hs).isZero() << endl;*/

				//w_can = soft_Hamming_weight(ce_Gs);
				//cout << "w_can = " << w_can << endl;

				TEP_generator.next();
			}
		}

		// output the 'delta_check_bin_2_filp_position'
		/*for (auto iter = delta_check_bin_2_filp_position.begin(); iter != delta_check_bin_2_filp_position.end(); ++iter) {
			cout << "delta_check_bin = " << iter->first << endl;
			cout << "filp_position" << iter->second;
		}*/

		// matching the 'delta_check_bin'
		int cnt_match = 0;

		if (target_check_bin == 0) {
			// inner bin matching, empty matching is valid

			TEP_match.resize(1, 0);
			// re-encoding the matched TEPs
			re_encoding(TEP_match);
			/*cout << "ce_Gs" << ce_Gs;
			cout << "ce_Gs.multiply_transpose_of(Hs).isZero() = " << ce_Gs.multiply_transpose_of(Hs).isZero() << endl;*/
			cnt_match++;

			w_can = soft_Hamming_weight(ce_Gs);
			//cout << "w_can = " << w_can << endl;
			if (w_can < w_min) {
				w_min = w_can;
				//cout << "w_min = " << w_min << endl;
				cb_Gs = ce_Gs;
			}
		}

		for (auto iter = delta_check_bin_2_filp_position.begin(); iter != delta_check_bin_2_filp_position.end(); iter++) {

			unsigned long long cur_bin = iter->first;
			unsigned long long match_bin = target_check_bin ^ iter->first;


			/*cout << "cur_bin = " << cur_bin << endl;
			cout << "match_bin = " << match_bin << endl;*/

			auto matched_check_bin = iter;
			if (target_check_bin != 0) {
				// cross bin matching
				matched_check_bin = delta_check_bin_2_filp_position.find(match_bin);
			}

			if (matched_check_bin != delta_check_bin_2_filp_position.end()) {

				//cout << "find matching bin" << endl;

				// find match check bin
				int n1 = iter->second.size();
				int n2 = matched_check_bin->second.size();


				for (int i = 0; i < n1; ++i) {
					int j = 0;
					if (target_check_bin == 0) {
						// inner bin matching
						j = i + 1;
					}

					for (; j < n2; ++j) {
						// Matching 
						matching_TEP(iter->second(i), matched_check_bin->second(j));
						//cout << "TEP_match" << TEP_match;

						// re-encoding the matched TEPs
						re_encoding(TEP_match);
						/*cout << "ce_Gs" << ce_Gs;
						cout << "ce_Gs.multiply_transpose_of(Hs).isZero() = " << ce_Gs.multiply_transpose_of(Hs).isZero() << endl;*/
						cnt_match++;

						w_can = soft_Hamming_weight(ce_Gs);
						//cout << "w_can = " << w_can << endl;
						if (w_can < w_min) {
							w_min = w_can;
							//cout << "w_min = " << w_min << endl;
							cb_Gs = ce_Gs;
						}
					}
				}

				if (target_check_bin != 0) {
					// cross bin matching
					delta_check_bin_2_filp_position.erase(matched_check_bin);
				}
			}
		}

		/*cout << "cnt_match = " << cnt_match << endl;

		cout << "---------------- bin left -----------------" << endl;
		for (auto iter = delta_check_bin_2_filp_position.begin(); iter != delta_check_bin_2_filp_position.end(); ++iter) {
			cout << "delta_check_bin = " << iter->first << endl;
			cout << "filp_position" << iter->second;
		}*/

		c_hat = cb_Gs;
		c_hat.permute_back(permutation_all);
	}

	void first_re_encoding() {
		// re-encode 'yB_Gs' into 'c0_Gs', i.e., c0_Gs = yB_Gs * Gs;

		// reset to all-0 vector
		c0_Gs.reset(0);
		c0_Gs_TEP.clear();

		for (int j = 0; j < k_prime; ++j) {

			if (y_Gs[j] == 1) {		// consider to write it as 'yB_Gs[j] + 1 == 0' for counting one GF2 operation

				// copy systematic part
				c0_Gs[j] = y_Gs[j];
				c0_Gs_TEP.push_back(j);

				// re-encode parity-check part
				if (j < k) {
					int row_start_ind = j * n;
					for (int p = k_prime; p < n; ++p) {
						c0_Gs[p] += Gs[row_start_ind + p];		// add accumulately, this cause my second problem, mark down here
					}
				}
			}

		}
		TEP_num++;
	}

	void re_encoding(const Matrix<int>& TEP_now) {
		// re-encode to ce_Gs

		// initialize ans
		ce_Gs = c0_Gs;

		for (int j = 0; j < TEP_now.size(); ++j) {
			// flip systematic part
			ce_Gs[TEP_now[j]] += 1;

			// re-encode parity-check part
			if (TEP_now[j] < k) {
				int row_start_ind = TEP_now[j] * n;
				for (int p = k_prime; p < n; ++p) {
					ce_Gs[p] += Gs[row_start_ind + p];		// add accumulately, this cause my second problem, mark down here
				}
			}
		}

		TEP_num++;
	}

	unsigned long long compute_check_bin(const Matrix<int>& TEP_input) {
		// compute the delta_check_bin for a TEP 'c_k_prime'

		unsigned long long ans = 0;
		// compute the inner product for each column of [k,k+delta-1] columns in 'Gs'
		int TEP_w = TEP_input.size();
		for (int i = 0; i < delta; ++i) {
			GF2 row_result = 0;
			for (int j = 0; j < TEP_w; ++j) {
				if (TEP_input(j) < k) {
					row_result += Gs(TEP_input(j), i + k);
				}
			}
			// store the 'row_result' in 'ans'
			ans <<= 1;
			ans ^= (int)row_result;
		}

		for (int j = 0; j < TEP_w; ++j) {
			if (TEP_input(j) >= k) {
				ans ^= (unsigned long long) 1 << (delta - 1 - (TEP_input(j) - k));		// incuring one GF2 operation
			}
		}


		return ans;
	}

	void matching_TEP(const Matrix<int>& TEP_1, const Matrix<int>& TEP_2) {
		TEP_match.resize(1, 0);

		int n1 = TEP_1.size();
		for (int i = 0; i < n1; ++i) {
			TEP_match.push_back(TEP_1(i));
		}

		int n2 = TEP_2.size();
		for (int i = 0; i < n2; ++i) {
			TEP_match.push_back(TEP_2(i));
		}
	}

	my_double soft_Hamming_weight(const Matrix<GF2>& c_Gs) {
		my_double ans = 0;
		error_num = 0;
		for (int i = 0; i < n; ++i) {
			if (c_Gs[i] != y_Gs[i]) {
				ans += r_abs_Gs[i];
				error_num++;
			}
		}
		return ans;
	}
};